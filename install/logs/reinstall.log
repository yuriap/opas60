SQL> 
SQL> --Global Config
SQL> @install_global_config
SQL> define namepref=opas60dev
SQL> 
SQL> @@version.sql
SQL> -- Oracle Performance Analytic Suite version
SQL> define OPASVER=6.0.0
SQL> 
SQL> -- Oracle Performance Analytic Suite scheme for local database
SQL> define localscheme=&namepref.
SQL> 
SQL> -- Tablespace name for Oracle Performance Analytic Suite
SQL> define tblspc_name=&namepref.tbs
SQL> 
SQL> -- Job Class name for Oracle Performance Analytic Suite
SQL> define job_class_name=JC_&namepref.
SQL> 
SQL> -- Local database connection string host:port/service_name
SQL> define localdb=localhost:1521/pdb1.localdomain
SQL> 
SQL> -- Local SYS password (can be empty)
SQL> define localsys=qazwsx
SQL> 
SQL> -- module configs
SQL> rem @../modules/awr_warehouse/install/install_config
SQL> 
SQL> --Module uninstallation
SQL> @uninstall_modules
SQL> -- Module list uninstallation
SQL> 
SQL> --SQL Trace
SQL> rem @../modules/sql_trace/install/uninstall.sql
SQL> 
SQL> --ASH Analyzer
SQL> rem @../modules/ash_analyzer/install/uninstall.sql
SQL> 
SQL> --AWR WareHouse
SQL> rem @../modules/awr_warehouse/install/uninstall.sql
SQL> 
SQL> --Core
SQL> @../modules/core/install/uninstall.sql
SQL> --Core uninstallation script
SQL> 
SQL> conn sys/&localsys.@&localdb. as sysdba
Connected.
SQL> 
SQL> set serveroutput on
SQL> begin
  2    for i in (select sid, serial#, inst_id from gv$session where username=upper('&localscheme.')) loop
  3  	 dbms_output.put_line('About to kill a session: '||i.sid||','||i.serial#||',@'||i.inst_id);
  4  	 execute immediate q'[alter system kill session ']'||i.sid||','||i.serial#||',@'||i.inst_id||q'[']';
  5    end loop;
  6  end;
  7  /
old   2:   for i in (select sid, serial#, inst_id from gv$session where username=upper('&localscheme.')) loop
new   2:   for i in (select sid, serial#, inst_id from gv$session where username=upper('opas60dev')) loop
About to kill a session: 55,18619,@1                                                                                                                                                                    
About to kill a session: 66,26223,@1                                                                                                                                                                    

PL/SQL procedure successfully completed.

SQL> set serveroutput off
SQL> 
SQL> drop user &localscheme. cascade;
old   1: drop user &localscheme. cascade
new   1: drop user opas60dev cascade

User dropped.

SQL> drop tablespace &tblspc_name. including contents and datafiles;
old   1: drop tablespace &tblspc_name. including contents and datafiles
new   1: drop tablespace opas60devtbs including contents and datafiles

Tablespace dropped.

SQL> 
SQL> begin
  2    DBMS_SCHEDULER.DROP_JOB_CLASS (job_class_name  => '&job_class_name.');
  3  end;
  4  /
old   2:   DBMS_SCHEDULER.DROP_JOB_CLASS (job_class_name  => '&job_class_name.');
new   2:   DBMS_SCHEDULER.DROP_JOB_CLASS (job_class_name  => 'JC_opas60dev');

PL/SQL procedure successfully completed.

SQL> 
SQL> disc
Disconnected from Oracle Database 18c Enterprise Edition Release 18.0.0.0.0 - Production
SQL> 
SQL> 
SQL> 
SQL> --Module installation
SQL> @install_modules
SQL> -- Module list installation
SQL> 
SQL> --Core
SQL> @../modules/core/install/install.sql
SQL> define MODNM=OPASCORE
SQL> 
SQL> @@version.sql
SQL> rem prev define MODVER=""
SQL> define MODVER="2.0.0"
SQL> @@install_config.sql
SQL> rem Path for directory object for EXP/IMP operations
SQL> rem Make sure the directory already exists and accessible
SQL> define OPASEXPIMP_DIRPATH="/u01/oracle/files/opasexpimp/"
SQL> define OPASEXPIMP_DIR=&namepref._EXPIMP
SQL> 
SQL> --Core installation script
SQL> conn sys/&localsys.@&localdb. as sysdba
Connected.
SQL> 
SQL> @@scheme_setup.sql
SQL> create bigfile tablespace &tblspc_name. datafile size 100m autoextend on next 100m maxsize 1000m;
old   1: create bigfile tablespace &tblspc_name. datafile size 100m autoextend on next 100m maxsize 1000m
new   1: create bigfile tablespace opas60devtbs datafile size 100m autoextend on next 100m maxsize 1000m

Tablespace created.

SQL> 
SQL> create user &localscheme. identified by &localscheme.
  2  default tablespace &tblspc_name.
  3  temporary tablespace temp;
old   1: create user &localscheme. identified by &localscheme.
new   1: create user opas60dev identified by opas60dev
old   2: default tablespace &tblspc_name.
new   2: default tablespace opas60devtbs

User created.

SQL> alter user &localscheme. quota unlimited on &tblspc_name.;
old   1: alter user &localscheme. quota unlimited on &tblspc_name.
new   1: alter user opas60dev quota unlimited on opas60devtbs

User altered.

SQL> 
SQL> grant create table to &localscheme.;
old   1: grant create table to &localscheme.
new   1: grant create table to opas60dev

Grant succeeded.

SQL> grant create view to &localscheme.;
old   1: grant create view to &localscheme.
new   1: grant create view to opas60dev

Grant succeeded.

SQL> grant create synonym to &localscheme.;
old   1: grant create synonym to &localscheme.
new   1: grant create synonym to opas60dev

Grant succeeded.

SQL> grant create job to &localscheme.;
old   1: grant create job to &localscheme.
new   1: grant create job to opas60dev

Grant succeeded.

SQL> grant create database link to &localscheme.;
old   1: grant create database link to &localscheme.
new   1: grant create database link to opas60dev

Grant succeeded.

SQL> grant create materialized view to &localscheme.;
old   1: grant create materialized view to &localscheme.
new   1: grant create materialized view to opas60dev

Grant succeeded.

SQL> 
SQL> grant connect, resource to &localscheme.;
old   1: grant connect, resource to &localscheme.
new   1: grant connect, resource to opas60dev

Grant succeeded.

SQL> grant select_catalog_role to &localscheme.;
old   1: grant select_catalog_role to &localscheme.
new   1: grant select_catalog_role to opas60dev

Grant succeeded.

SQL> grant MANAGE SCHEDULER to &localscheme.;
old   1: grant MANAGE SCHEDULER to &localscheme.
new   1: grant MANAGE SCHEDULER to opas60dev

Grant succeeded.

SQL> 
SQL> grant alter session to &localscheme.;
old   1: grant alter session to &localscheme.
new   1: grant alter session to opas60dev

Grant succeeded.

SQL> grant select any table to &localscheme.;
old   1: grant select any table to &localscheme.
new   1: grant select any table to opas60dev

Grant succeeded.

SQL> 
SQL> grant execute on dbms_lock to &localscheme.;
old   1: grant execute on dbms_lock to &localscheme.
new   1: grant execute on dbms_lock to opas60dev

Grant succeeded.

SQL> grant execute on dbms_workload_repository to &localscheme.;
old   1: grant execute on dbms_workload_repository to &localscheme.
new   1: grant execute on dbms_workload_repository to opas60dev

Grant succeeded.

SQL> grant execute on dbms_xplan to &localscheme.;
old   1: grant execute on dbms_xplan to &localscheme.
new   1: grant execute on dbms_xplan to opas60dev

Grant succeeded.

SQL> grant execute on dbms_log to &localscheme.;
old   1: grant execute on dbms_log to &localscheme.
new   1: grant execute on dbms_log to opas60dev

Grant succeeded.

SQL> 
SQL> --APEX 18.1 uploading files
SQL> grant update on apex_180100.WWV_FLOW_TEMP_FILES to &localscheme.;
old   1: grant update on apex_180100.WWV_FLOW_TEMP_FILES to &localscheme.
new   1: grant update on apex_180100.WWV_FLOW_TEMP_FILES to opas60dev

Grant succeeded.

SQL> --APEX 19.1 uploading files
SQL> grant update on apex_190100.WWV_FLOW_TEMP_FILES to &localscheme.;
old   1: grant update on apex_190100.WWV_FLOW_TEMP_FILES to &localscheme.
new   1: grant update on apex_190100.WWV_FLOW_TEMP_FILES to opas60dev
grant update on apex_190100.WWV_FLOW_TEMP_FILES to opas60dev
                            *
ERROR at line 1:
ORA-00942: table or view does not exist 


SQL> 
SQL> grant select on v_$session to &localscheme.;
old   1: grant select on v_$session to &localscheme.
new   1: grant select on v_$session to opas60dev

Grant succeeded.

SQL> grant select on gv_$session to &localscheme.;
old   1: grant select on gv_$session to &localscheme.
new   1: grant select on gv_$session to opas60dev

Grant succeeded.

SQL> grant select on v_$parameter to &localscheme.;
old   1: grant select on v_$parameter to &localscheme.
new   1: grant select on v_$parameter to opas60dev

Grant succeeded.

SQL> grant select on dba_hist_sqltext to &localscheme.;
old   1: grant select on dba_hist_sqltext to &localscheme.
new   1: grant select on dba_hist_sqltext to opas60dev

Grant succeeded.

SQL> 
SQL> begin
  2  DBMS_SCHEDULER.CREATE_JOB_CLASS (
  3  	job_class_name		  => '&job_class_name.',
  4  	logging_level		  => DBMS_SCHEDULER.LOGGING_FAILED_RUNS,
  5  	log_history		  => 1,
  6  	comments		  => 'Low logging level for coordinator jobs');
  7  end;
  8  /
old   3:    job_class_name            => '&job_class_name.',
new   3:    job_class_name            => 'JC_opas60dev',

PL/SQL procedure successfully completed.

SQL> 
SQL> grant execute on &job_class_name. to &localscheme.;
old   1: grant execute on &job_class_name. to &localscheme.
new   1: grant execute on JC_opas60dev to opas60dev

Grant succeeded.

SQL> 
SQL> set serveroutput on
SQL> /*
SQL> begin
SQL>   for i in (select * from dba_tab_privs where grantee='SELECT_CATALOG_ROLE')
SQL>   loop
SQL>   begin
SQL> 	 execute immediate 'grant '||i.privilege||' on '||i.table_name||' to &localscheme.';
SQL>   exception
SQL> 	 when others then null; -- dbms_output.put_line(i.table_name||':'||i.privilege||': '||sqlerrm);
SQL>   end;
SQL>   end loop;
SQL> end;
SQL> */
SQL> 
SQL> create or replace directory &OPASEXPIMP_DIR. as '&OPASEXPIMP_DIRPATH.';
old   1: create or replace directory &OPASEXPIMP_DIR. as '&OPASEXPIMP_DIRPATH.'
new   1: create or replace directory opas60dev_EXPIMP as '/u01/oracle/files/opasexpimp/'

Directory created.

SQL> grant read, write on directory &OPASEXPIMP_DIR. to &localscheme.;
old   1: grant read, write on directory &OPASEXPIMP_DIR. to &localscheme.
new   1: grant read, write on directory opas60dev_EXPIMP to opas60dev

Grant succeeded.

SQL> 
SQL> 
SQL> 
SQL> conn &localscheme./&localscheme.@&localdb.
Connected.
SQL> 
SQL> @../modules/core/struct/create_struct.sql
SQL> ---------------------------------------------------------------------------------------------
SQL> -- Module registry
SQL> ---------------------------------------------------------------------------------------------
SQL> create table opas_modules (
  2  MODNAME		 varchar2(128)					 primary key,
  3  MODDESCR		 varchar2(4000),
  4  MODVER		 varchar2(32)				not null,
  5  INSTALLED		 date					not null
  6  );

Table created.

SQL> 
SQL> ---------------------------------------------------------------------------------------------
SQL> -- Module Metadata
SQL> ---------------------------------------------------------------------------------------------
SQL> create table opas_config (
  2  modname		 varchar2(128)					  references opas_modules(modname) on delete cascade,
  3  cgroup		 varchar2(128)				not null,
  4  ckey		 varchar2(100)				not null,
  5  cvalue		 varchar2(4000),
  6  descr		 varchar2(200)
  7  );

Table created.

SQL> 
SQL> alter table opas_config add constraint opas_config_pk primary key (modname,ckey);

Table altered.

SQL> 
SQL> create table opas_dictionary (
  2  modname		 varchar2(128)				not null  references opas_modules(modname) on delete cascade,
  3  dic_name		 varchar2(20)				not null,
  4  val		 varchar2(20)				not null,
  5  display_val	 varchar2(256)				not null,
  6  sparse1		 varchar2(100),
  7  sparse2		 varchar2(100),
  8  sparse3		 varchar2(100),
  9  dic_ordr		 number);

Table created.

SQL> 
SQL> create index idx_opas_dictionary_mod on opas_dictionary(modname,dic_name);

Index created.

SQL> 
SQL> ---------------------------------------------------------------------------------------------
SQL> -- Known query storage
SQL> ---------------------------------------------------------------------------------------------
SQL> create table opas_query_storage (
  2  sql_id		 varchar2(128)					  primary key,
  3  sql_text		 clob,
  4  created		 timestamp	  default systimestamp,
  5  owner		 varchar2(128)	  default 'PUBLIC')
  6  lob (sql_text) store as (compress high)
  7  ;

Table created.

SQL> 
SQL> -- Text index TBD
SQL> 
SQL> ---------------------------------------------------------------------------------------------
SQL> -- Database link dictionary
SQL> ---------------------------------------------------------------------------------------------
SQL> create table opas_db_links (
  2  db_link_name	 varchar2(128)					  primary key,
  3  owner		 varchar2(128)	  default 'PUBLIC',
  4  username		 varchar2(128),
  5  password		 varchar2(128),
  6  connstr		 varchar2(1000),
  7  STATUS		 varchar2(32)	  default 'NEW' 	not null,
  8  is_public		 varchar2(1)	  default 'Y'		not null);

Table created.

SQL> 
SQL> CREATE OR REPLACE FORCE VIEW V$OPAS_DB_LINKS AS
  2  with gn as (select value from v$parameter where name like '%domain%')
  3  select DB_LINK_NAME,
  4  	    case
  5  	      when DB_LINK_NAME = '$LOCAL$' then DB_LINK_NAME
  6  	      else l.db_link
  7  	    end ORA_DB_LINK,
  8  	    case
  9  	      when DB_LINK_NAME = '$LOCAL$' then 'LOCAL'
 10  	      else
 11  		case when l.username is not null then DB_LINK_NAME||' ('||l.username||'@'||l.host||')' else DB_LINK_NAME||' (SUSPENDED)' end
 12  	      end DISPLAY_NAME,
 13  	    OWNER,
 14  	    STATUS,
 15  	    IS_PUBLIC
 16    from OPAS_DB_LINKS o, user_db_links l, gn
 17   where owner =
 18  	    decode(owner,
 19  		   'PUBLIC',
 20  		   owner,
 21  		   decode(is_public, 'Y', owner, nvl(V('APP_USER'), '~^')))
 22  	and l.db_link(+) = case when gn.value is null then upper(o.DB_LINK_NAME) else upper(o.DB_LINK_NAME ||'.'|| gn.value) end;

View created.

SQL> 
SQL> ---------------------------------------------------------------------------------------------
SQL> -- File storage
SQL> ---------------------------------------------------------------------------------------------
SQL> create table opas_files (
  2  file_id		 number 					  generated always as identity primary key,
  3  modname		 varchar2(128)				not null  references opas_modules(modname) on delete cascade,
  4  file_type		 varchar2(100)				not null,
  5  file_name		 varchar2(1000) 			not null,
  6  file_mimetype	 varchar2(30)				not null,
  7  file_contentb	 blob, --download form of reports
  8  --file_contentc	   clob, -- will be converted to clob on the fly for html preview
  9  created		 timestamp	  default systimestamp,
 10  owner		 varchar2(128)	  default 'PUBLIC'	not null
 11  )
 12  lob (file_contentb) store as (compress high)
 13  --lob (file_contentc) store as (compress high)
 14  ;

Table created.

SQL> 
SQL> create index idx_opas_files_mod on opas_files(modname);

Index created.

SQL> 
SQL> ---------------------------------------------------------------------------------------------
SQL> -- Authorization
SQL> ---------------------------------------------------------------------------------------------
SQL> -- Authorization group_id - is an access level
SQL> -- 0 - admin; 1 - rw; 2 - RO; 3 - noaccess;
SQL> create table opas_groups (
  2    group_id 	   number					  primary key check (group_id in (0,1,2,3)),
  3    group_name	   varchar2(100)			not null,
  4    group_descr	   varchar2(1000));

Table created.

SQL> 
SQL> create table opas_groups2apexusr (
  2    group_id 	   number				not null  references opas_groups(group_id),
  3    modname		   varchar2(128)			not null  references opas_modules(modname) on delete cascade,
  4    apex_user	   varchar2(100)			not null);

Table created.

SQL> 
SQL> create index opas_groups2apexusr_usr on opas_groups2apexusr(apex_user);

Index created.

SQL> create unique index opas_groups2apexusr_usr2grp on opas_groups2apexusr(modname,apex_user,group_id);

Index created.

SQL> 
SQL> ---------------------------------------------------------------------------------------------
SQL> -- Navigator
SQL> ---------------------------------------------------------------------------------------------
SQL> create table opas_object_types (
  2    ot_id		 number 					  primary key,
  3    ot_name		 varchar2(100)				not null,
  4    ot_descr 	 varchar2(4000),
  5    ot_sortordr	 number 	  default 0		not null,
  6    ot_icon		 varchar2(100)	  default 'def_icon'	not null
  7  );

Table created.

SQL> 
SQL> create table opas_object_pages (
  2    ot_app_page	 number 					  primary key,
  3    ot_id		 number 				not null  references opas_object_types(ot_id) on delete cascade,
  4    ot_page_type	 varchar2(32)				not null, --OPEN, NEW, DELETE ...
  5    ot_page_descr	 varchar2(4000)
  6  );

Table created.

SQL> 
SQL> create index idx_opas_object_pages_ot on opas_object_pages(ot_id);

Index created.

SQL> 
SQL> create table opas_object_page_pars (
  2    ot_par_name	 varchar2(100)					  primary key,
  3    ot_app_page	 number 				not null  references opas_object_pages(ot_app_page) on delete cascade,
  4    ot_par_def_val	 varchar2(512),
  5    ot_par_mandat	 varchar2(1)	  default 'N'		not null,
  6    ot_par_sortordr	 number 				not null
  7  );

Table created.

SQL> 
SQL> create index idx_opas_object_page_pars_pg on opas_object_page_pars(ot_app_page);

Index created.

SQL> 
SQL> create table opas_object_oper (
  2    ot_id		 number 				not null  references opas_object_types(ot_id) on delete cascade,
  3    ot_oper_type	 varchar2(32)				not null, --CREATE, MOVE, COPY, DELETE, EXPORT, IMPORT ...
  4    ot_oper_package	 varchar2(128)				not null,
  5    ot_oper_procedure varchar2(128)				not null
  6  );

Table created.

SQL> 
SQL> create index idx_opas_object_oper_ot on opas_object_oper(ot_id);

Index created.

SQL> 
SQL> create table opas_objects (
  2    obj_id		 number 					  generated always as identity primary key,
  3    obj_prnt 	 number 					  references opas_objects(obj_id),
  4    obj_ot		 number 				not null  references opas_object_types(ot_id),
  5    obj_created	 date,
  6    obj_expired	 date,
  7    obj_name 	 varchar2(100),
  8    obj_descr	 varchar2(4000),
  9    obj_sortordr	 number 	  default 0		not null,
 10    obj_owner	 varchar2(128),
 11    is_public	 varchar2(1)	  default 'Y'		not null
 12  );

Table created.

SQL> 
SQL> create index idx_opas_objects_ot on opas_objects(obj_ot);

Index created.

SQL> create index idx_opas_objects_prnt on opas_objects(obj_prnt);

Index created.

SQL> 
SQL> create table opas_object_references (
  2    obj_id_src	 number 				not null  references opas_objects(obj_id) on delete cascade,
  3    obj_id_trg	 number 				not null  references opas_objects(obj_id) on delete cascade,
  4    obj_ref_type	 varchar2(100)	  default 'DEFAULT'	not null  -- DEFAULT, SQLOLDNEW, SQLTOPREC
  5  );

Table created.

SQL> 
SQL> create index idx_opas_object_references_src on opas_object_references(obj_id_src);

Index created.

SQL> create index idx_opas_object_references_trg on opas_object_references(obj_id_trg);

Index created.

SQL> 
SQL> ---------------------------------------------------------------------------------------------
SQL> -- Task execution infrasrtucture
SQL> ---------------------------------------------------------------------------------------------
SQL> --create table opas_cleanup_tasks (
SQL> --  taskname	     varchar2(128)				    primary key,
SQL> --  modname	     varchar2(128)			  not null  references opas_modules(modname) on delete cascade,
SQL> --  created	     timestamp	    default systimestamp,
SQL> --  task_body	     clob
SQL> --);
SQL> 
SQL> --create index idx_opas_cleanup_tasks_mod on opas_cleanup_tasks(modname);
SQL> 
SQL> create table opas_task (
  2    taskname 	   varchar2(128)				  primary key,
  3    modname		   varchar2(128)			not null  references opas_modules(modname) on delete cascade,
  4    is_public	   varchar2(1)	  default 'Y'		not null,
  5    created		   timestamp	  default systimestamp,
  6    task_body	   clob,
  7    task_priority	   varchar2(10)   default 'NORM'      not null -- 'HIGH', 'LOW'
  8  );

Table created.

SQL> 
SQL> create index idx_opas_task_mod on opas_task(modname);

Index created.

SQL> 
SQL> create table opas_task_queue (
  2    tq_id		   number					  generated always as identity primary key,
  3    taskname 	   varchar2(128)			not null  references opas_task(taskname) on delete cascade,
  4    task_subname	   varchar2(128),
  5    trg_obj_id	   number					  references opas_objects(obj_id) on delete cascade,
  6    queued		   timestamp,
  7    started		   timestamp,
  8    finished 	   timestamp,
  9    cpu_time 	   number, --seconds
 10    elapsed_time	   number,
 11    status		   varchar2(32)   default 'NEW',
 12    owner		   varchar2(128)			not null,
 13    sid		   number,
 14    serial#		   number,
 15    inst_id		   number,
 16    job_name 	   varchar2(128)
 17  );

Table created.

SQL> 
SQL> create index idx_opas_task_exec_tsk on opas_task_queue(taskname);

Index created.

SQL> create index idx_opas_task_exec_obj on opas_task_queue(trg_obj_id);

Index created.

SQL> 
SQL> create table opas_task_pars (
  2    tq_id		   number				not null  references opas_task_queue(tq_id) on delete cascade,
  3    PAR_NAME 	   varchar2(100)			not null,
  4    num_par		   number,
  5    varchar_par	   varchar2(4000),
  6    date_par 	   date,
  7    list_par 	   varchar2(4000)
  8  );

Table created.

SQL> 
SQL> create index idx_opas_task_parstske on opas_task_pars(tq_id);

Index created.

SQL> 
SQL> create table opas_log (
  2    created		   timestamp	  default systimestamp,
  3    msg		   varchar2(4000),
  4    tq_id		   number					  references opas_task_queue(tq_id) on delete cascade,
  5    msg_long 	   clob
  6  );

Table created.

SQL> 
SQL> create index idx_opas_task_logtske on opas_log(tq_id);

Index created.

SQL> create index idx_opas_task_created on opas_log(created);

Index created.

SQL> 
SQL> CREATE OR REPLACE FORCE VIEW V$OPAS_TASK_QUEUE AS
  2  select
  3    t.taskname,
  4    t.modname,
  5    q.task_subname,
  6    t.is_public,
  7    q.tq_id,
  8    q.queued,
  9    q.started,
 10    q.finished,
 11    q.cpu_time,
 12    nvl(q.elapsed_time,round((sysdate-(q.started+0))*3600*24)) elapsed_time,
 13    q.status,
 14    q.owner,
 15    q.sid,
 16    q.serial#,
 17    q.inst_id,
 18    q.job_name
 19  from opas_task t left outer join opas_task_queue q on (t.taskname = q.taskname and q.owner=decode(t.is_public,'Y',q.owner,nvl(V('APP_USER'),'~^')))
 20  where 1=decode(t.is_public,'Y',1, COREMOD_SEC.is_role_assigned_n(t.modname,'Reas-write users'))
 21  ;

Warning: View created with compilation errors.

SQL> 
SQL> CREATE OR REPLACE FORCE VIEW V$OPAS_TASK_QUEUE_LONGOPS AS
  2  select tq.*,
  3  	    case
  4  	      when message is null then 'N/A'
  5  	      else opname || ':' || message || '; elapsed: ' || elapsed_seconds || '; remaining: ' || nvl(to_char(time_remaining), 'N/A') end msg,
  6  	    round(100 * (sofar / decode(totalwork,0,1,totalwork))) pct_done,
  7  	    units,opname,module,action
  8    from V$OPAS_TASK_QUEUE		tq,
  9  	    gv$session_longops		 lo,
 10  	    gv$session			 s
 11    where tq.sid = lo.sid(+)
 12  	 and tq.serial# = lo.serial#(+)
 13  	 and tq.inst_id = lo.inst_id(+)
 14  	 and tq.sid = s.sid(+)
 15  	 and tq.serial# = s.serial#(+)
 16  	 and tq.inst_id = s.inst_id(+)
 17  ;

Warning: View created with compilation errors.

SQL> 
SQL> ---------------------------------------------------------------------------------------------
SQL> -- Export/Import
SQL> ---------------------------------------------------------------------------------------------
SQL> create table opas_expimp_sessions (
  2  sess_id		 number 					  generated always as identity primary key,
  3  tq_id		 number 					  references opas_task_queue(tq_id) on delete set null,
  4  expimp_file	 number 					  references opas_files ( file_id ),
  5  created		 timestamp	  default systimestamp,
  6  owner		 varchar2(128)	  default 'PUBLIC'	not null,
  7  sess_type		 varchar2(3)	  check (sess_type in ('IMP','EXP')),
  8  status		 varchar2(32)	  default 'NEW' 	not null
  9  )
 10  ;

Table created.

SQL> create index idx_opas_expimp_sessions_tq	on opas_expimp_sessions(tq_id);

Index created.

SQL> 
SQL> create table opas_expimp_metadata (
  2  sess_id		 number 				not null  references opas_expimp_sessions(sess_id) on delete cascade,
  3  modname		 varchar2(128)				not null  references opas_modules(modname) on delete cascade,
  4  import_prc 	 varchar2(128),
  5  file_descr 	 varchar2(4000),
  6  src_version	 varchar2(128)				not null,
  7  src_core_version	 varchar2(128)				not null
  8  );

Table created.

SQL> 
SQL> create index idx_opas_expimp_metadata_mod	 on opas_expimp_metadata(modname);

Index created.

SQL> create index idx_opas_expimp_metadata_sess  on opas_expimp_metadata(sess_id);

Index created.

SQL> 
SQL> create table opas_expimp_params (
  2  sess_id		 number 				not null  references opas_expimp_sessions(sess_id) on delete cascade,
  3  par_name		 varchar2(128)				not null,
  4  par_value		 varchar2(4000)
  5  );

Table created.

SQL> 
SQL> create index idx_opas_expimp_params_sess	on opas_expimp_params(sess_id);

Index created.

SQL> 
SQL> create table opas_expimp_compat (
  2  modname		 varchar2(128)				not null references opas_modules(modname) on delete cascade,
  3  src_version	 varchar2(100)				not null,
  4  trg_version	 varchar2(100)				not null
  5  );

Table created.

SQL> 
SQL> create or replace force view v$opas_expimp_sessions as
  2  select
  3  	 x.sess_id,
  4  	 x.tq_id,
  5  	 x.expimp_file file_id,
  6  	 x.created,
  7  	 x.owner,
  8  	 decode(x.sess_type,'EXP','Export','IMP','Import','Unknown: '||x.sess_type) sess_type,
  9  	 x.status,
 10  	 m.modname,
 11  	 m.import_prc,
 12  	 m.file_descr,
 13  	 m.src_version,
 14  	 m.src_core_version,
 15  	 dbms_lob.getlength(f.file_contentb) fsize,
 16  	 f.file_name,
 17  	     case when m.MODNAME is not null then to_char(x.created + to_number(COREMOD_API.getconf('EXPIMPSESS',m.MODNAME)),'YYYY-MON-DD HH24:MI' ) else null end expiration
 18  from opas_expimp_sessions x, opas_expimp_metadata m, opas_files f
 19  where x.owner=decode(x.owner,'PUBLIC',x.owner,nvl(V('APP_USER'),'~^'))
 20  and x.sess_id=m.sess_id and x.expimp_file=f.file_id(+);

Warning: View created with compilation errors.

SQL> 
SQL> ---------------------------------------------------------------------------------------------
SQL> -- Miscelaneous
SQL> ---------------------------------------------------------------------------------------------
SQL> CREATE OR REPLACE TYPE tableofnumbers as table of number(20)
  2  /

Type created.

SQL> CREATE OR REPLACE TYPE tableofstrings as table of varchar2(4000)
  2  /

Type created.

SQL> 
SQL> --Clob2row representation
SQL> --https://jonathanlewis.wordpress.com/2008/11/19/lateral-lobs/
SQL> create or replace type clob_line as object (
  2  	 line_number number,
  3  	 payload varchar2(4000)
  4  )
  5  /

Type created.

SQL> 
SQL> create or replace type clob_page as table of clob_line
  2  /

Type created.

SQL> 
SQL> create or replace force view v$opas_file_contentbyrow
  2  as
  3  select
  4  	 /*+ cardinality(p1 10) */
  5  	 opas_files.file_id,
  6  	 p1.line_number,
  7  	 p1.payload
  8  from
  9  	 opas_files,
 10  	 table(COREMOD_UTILS.clob2tab(opas_files.file_id)) p1
 11  ;

Warning: View created with compilation errors.

SQL> ---------------------------------------------------------------------------------------------
SQL> -- Core Objects
SQL> ---------------------------------------------------------------------------------------------
SQL> -- Reports
SQL> create table opas_reports (
  2  report_id		 number 					  primary key,
  3  parent_id		 number 					  references opas_reports(report_id) on delete set null,
  4  modname		 varchar2(128)				not null  references opas_modules(modname) on delete cascade,
  5  tq_id		 number 					  references opas_task_queue(tq_id) on delete set null,
  6  report_content	 number 					  references opas_files ( file_id ),
  7  report_params_displ varchar2(1000),
  8  report_type	 varchar2(100)				not null);

Table created.

SQL> 
SQL> alter table opas_reports add constraint fk_reports_obj foreign key references opas_objects(obj_id)
  2  
SQL> create index idx_opas_reports_mod	 on opas_reports(modname);

Index created.

SQL> create index idx_opas_reports_fcntn on opas_reports(report_content);

Index created.

SQL> 
SQL> create table opas_reports_pars (
  2  report_id		 number 				not null  references opas_reports(report_id) on delete cascade,
  3  par_name		 varchar2(100)				not null,
  4  num_par		 number,
  5  varchar_par	 varchar2(4000),
  6  date_par		 date
  7  );

Table created.

SQL> 
SQL> create index idx_opas_reports_parstske on opas_reports_pars(report_id);

Index created.

SQL> 
SQL> ---------------------------------------------------------------------------------------------
SQL> -- DB Links assignments
SQL> create table opas_dblinks2obj (
  2  trg_obj_id 	 number 				not null  references opas_objects(obj_id) on delete cascade,
  3  dblink		 varchar2(128)				not null  references opas_db_links (DB_LINK_NAME) on delete cascade,
  4  default_dblink	 varchar2(1)				not null,
  5  sortordr		 number 	  default 0		not null);

Table created.

SQL> 
SQL> create unique index idx_opas_dblinks2obj_trg on opas_dblinks2obj(trg_obj_id,dblink);

Index created.

SQL> create index idx_opas_dblinks2obj_dbl  on opas_dblinks2obj(dblink);

Index created.

SQL> 
SQL> ---------------------------------------------------------------------------------------------
SQL> -- SQLs
SQL> create table opas_sql_descriptions (
  2  sqlobj_id		 number 					  primary key,
  3  sql_id		 varchar2(128)				not null  references opas_query_storage(sql_id),
  4  description	 varchar2(4000),
  5  typical_source	 varchar2(4000),
  6  author		 varchar2(128)				not null,
  7  created		 timestamp	  default systimestamp
  8  );

Table created.

SQL> 
SQL> alter table opas_sql_descriptions add constraint fk_sqls_obj foreign key (sqlobj_id) references opas_objects(obj_id) on delete cascade;

Table altered.

SQL> create unique index idx_opas_sql_descr_sqlid on opas_sql_descriptions(sql_id);

Index created.

SQL> 
SQL> ---------------------------------------------------------------------------------------------
SQL> -- SQL Lists
SQL> create table opas_sql_lists (
  2  sqllst_id		 number 					  primary key,
  3  list_name		 varchar2(100)				not null,
  4  description	 varchar2(4000)
  5  );

Table created.

SQL> 
SQL> alter table opas_sql_lists add constraint fk_sql_lists_obj foreign key (sqllst_id) references opas_objects(obj_id) on delete cascade;

Table altered.

SQL> 
SQL> create table opas_lists2sqls (
  2  sqllst_id		 number 				not null  references opas_sql_lists(sqllst_id) on delete cascade,
  3  sql_id		 varchar2(128)				not null  references opas_query_storage(sql_id)
  4  );

Table created.

SQL> 
SQL> create unique index idx_opas_lists2sqls_sql_l on opas_lists2sqls(sqllst_id, sql_id);

Index created.

SQL> create index idx_opas_lists2sqls_sql   on opas_lists2sqls(sql_id);

Index created.

SQL> 
SQL> @../modules/core/source/create_stored.sql
SQL> @@COREMOD_API_SPEC.SQL
SQL> CREATE OR REPLACE
  2  package COREMOD_API as
  3  
  4  	gDefaultSource constant varchar2(32) := 'LOCAL';
  5  	gDefaultOwner  constant varchar2(32) := 'PUBLIC';
  6  
  7  	gMODNAME       constant varchar2(32) := 'OPASCORE';
  8  
  9  	exDBLinkSuspended exception;
 10  	pragma exception_init(exDBLinkSuspended, -20999);
 11  
 12  	dblNEW	      constant varchar2(32) := 'NEW';
 13  	dblMODIFIED   constant varchar2(32) := 'MODIFIED';
 14  	dblCREATED    constant varchar2(32) := 'CREATED';
 15  	dblSUSPENDED  constant varchar2(32) := 'SUSPENDED';
 16  	dblTODELETE   constant varchar2(32) := 'TODELETE';
 17  
 18  	procedure register(p_modname opas_modules.MODNAME%type,
 19  			   p_moddescr opas_modules.MODDESCR%type default null,
 20  			   p_modver opas_modules.MODVER%type,
 21  			   p_installed opas_modules.INSTALLED%type default sysdate);
 22  
 23  	function getconf(p_key varchar2, p_module opas_modules.modname%type) return varchar2 RESULT_CACHE;
 24  	--function getscript(p_script_id varchar2) return clob;
 25  	function getmodver(p_module opas_modules.modname%type) return varchar2 RESULT_CACHE;
 26  	function getMODNAME return varchar2;
 27  
 28  	procedure register_dblink(p_db_link_name varchar2,
 29  				  p_owner varchar2,
 30  				  p_is_public varchar2,
 31  				  p_username varchar2,
 32  				  p_password varchar2,
 33  				  p_connectstring varchar2);
 34  	procedure edit_dblink	 (p_db_link_name varchar2,
 35  				  p_is_public varchar2,
 36  				  p_username varchar2,
 37  				  p_password varchar2,
 38  				  p_connectstring varchar2);
 39  	procedure create_dblink(p_db_link_name varchar2, p_recreate boolean default false);
 40  	procedure drop_dblink(p_db_link_name varchar2, p_suspend boolean default false);
 41  	procedure test_dblink(p_db_link_name varchar2);
 42  	function get_ora_dblink(p_db_link_name varchar2) return varchar2;
 43  
 44  	function get_def_source return varchar2;
 45  	function get_def_owner return varchar2;
 46  
 47  	procedure init_longops(p_op_name varchar2, p_target_desc varchar2, p_units varchar2, p_totalwork number, p_lops_ind out pls_integer);
 48  	procedure start_longops_section(p_module_name varchar2, p_action_name varchar2);
 49  	procedure end_longops_section(p_sofar number default 1, p_lops_ind pls_integer);
 50  
 51  	procedure lock_resource(p_resource_name varchar2, p_mode number default DBMS_LOCK.X_MODE, p_timeout number default 0, p_release_on_commit boolean default true);
 52  	function lock_resource(p_resource_name varchar2, p_mode number default DBMS_LOCK.X_MODE, p_timeout number default 0, p_release_on_commit boolean default true) return varchar2;
 53  	procedure release_resource(p_handle varchar2);
 54  	procedure release_resource;
 55  
 56  end COREMOD_API;
 57  /

Package created.

SQL> show errors
No errors.
SQL> 
SQL> @@COREMOD_LOG_SPEC.SQL
SQL> CREATE OR REPLACE
  2  package COREMOD_LOG is
  3    -- INFO
  4    -- DEBUG
  5    procedure log(p_msg clob, p_loglevel varchar2 default 'INFO');
  6    procedure cleanup_logs;
  7  
  8    procedure Start_SQL_GATHER_STAT(p_name varchar2);
  9    procedure Stop_SQL_GATHER_STAT(p_name varchar2);
 10  
 11    procedure Start_SQL_TRACE(p_name varchar2);
 12    procedure Stop_SQL_TRACE(p_name varchar2);
 13  
 14    procedure debug_on;
 15    procedure debug_off;
 16  end;
 17  /

Package created.

SQL> show errors
No errors.
SQL> 
SQL> @@COREMOD_SEC_SPEC.SQL
SQL> CREATE OR REPLACE
  2  package COREMOD_SEC as
  3  
  4    type t_mod_list	  is table of OPAS_GROUPS2APEXUSR.modname%type;
  5    type t_grp_id_list is table of opas_groups.group_id%type;
  6  
  7    function is_mod_installed(p_modname opas_modules.MODNAME%type) return boolean RESULT_CACHE;
  8  
  9    function is_role_assigned(p_modname OPAS_GROUPS2APEXUSR.modname%type, p_group_name opas_groups.group_name%type) return boolean;
 10    function is_role_assigned_n(p_modname OPAS_GROUPS2APEXUSR.modname%type, p_group_name opas_groups.group_name%type) return number;
 11  
 12    procedure save_role_assignment(p_modname_lst t_mod_list, p_group_id_lst t_grp_id_list, p_apex_user OPAS_GROUPS2APEXUSR.apex_user%type);
 13  
 14    --common UI rights
 15    --Projects
 16    --function proj_is_role_assigned(p_proj_type opas_project_types.proj_type%type, p_group_name opas_groups.group_name%type) return boolean;
 17  
 18  end COREMOD_SEC;
 19  /

Package created.

SQL> show errors
No errors.
SQL> 
SQL> @@COREMOD_TASKS_SPEC.SQL
SQL> CREATE OR REPLACE
  2  package coremod_tasks as
  3  
  4    --Task queue status
  5    gtqNEW	    constant varchar2(10):='NEW';
  6    gtqQUEUED    constant varchar2(10):='QUEUED';
  7    gtqSTARTED   constant varchar2(10):='STARTED';
  8    gtqSCHEDULED constant varchar2(10):='SCHEDULED';
  9    gtqRUNNING   constant varchar2(10):='RUNNING';
 10    gtqSUCCEEDED constant varchar2(10):='SUCCEEDED';
 11    gtqFAILED    constant varchar2(10):='FAILED';
 12    gtqCanceled  constant varchar2(10):='CANCELED';
 13  
 14    --Task priorities
 15    tpHIGH	    constant varchar2(10):='HIGH';
 16    tpNORM	    constant varchar2(10):='NORM';
 17    tpLOW	    constant varchar2(10):='LOW';
 18  
 19    procedure cleanup_tasks;
 20  
 21    procedure create_task(p_taskname   opas_task.taskname%type,
 22  			     p_modname	  opas_task.modname%type,
 23  			     p_is_public  opas_task.is_public%type default 'Y',
 24  			     p_task_priority opas_task.task_priority%type,
 25  			     p_task_body  opas_task.task_body%type);
 26    procedure drop_task(p_taskname opas_task.taskname%type);
 27  
 28    function  prep_execute_task(p_taskname opas_task.taskname%type,
 29  				   p_task_subname opas_task_queue.task_subname%type default null) return opas_task_queue.tq_id%type;
 30    procedure queue_task(p_tq_id opas_task_queue.tq_id%type, p_start_time date default null);
 31    procedure cancel_task(p_tq_id opas_task_queue.tq_id%type);
 32  
 33    procedure set_task_param(p_tq_id opas_task_queue.tq_id%type, p_name opas_task_pars.par_name%type, p_num_par number);
 34    procedure set_task_param(p_tq_id opas_task_queue.tq_id%type, p_name opas_task_pars.par_name%type, p_varchar_par varchar2);
 35    procedure set_task_param(p_tq_id opas_task_queue.tq_id%type, p_name opas_task_pars.par_name%type, p_date_par date);
 36    procedure set_task_param_list(p_tq_id opas_task_queue.tq_id%type, p_name opas_task_pars.par_name%type, p_list_par varchar2);
 37  
 38    procedure create_task_job;
 39    procedure execute_task_proc; --job coord proc
 40    procedure execute_task(p_tq_id opas_task_queue.tq_id%type);
 41    procedure stop_task(p_tq_id opas_task_queue.tq_id%type);
 42    procedure stop_previous_user_task(p_taskname   opas_task.taskname%type);
 43  
 44    procedure log(p_msg opas_log.msg%type, p_tq_id opas_task_queue.tq_id%type default null);
 45  
 46    function get_curr_tq_id return opas_task_queue.tq_id%type;
 47  end;
 48  /

Package created.

SQL> show errors
No errors.
SQL> 
SQL> @@COREMOD_UTILS_SPEC.SQL
SQL> CREATE OR REPLACE
  2  PACKAGE COREMOD_UTILS AS
  3  
  4    function lsttochr(p_list tableofnumbers) return varchar2;
  5    function bool2str(p_bool boolean) return varchar2;
  6  
  7    function clob2tab(p_file_id    opas_files.file_id%type) return clob_page pipelined;
  8  
  9    function get_remote_oracle_version(p_dblink opas_db_links.db_link_name%type) return number;
 10  END COREMOD_UTILS;
 11  /

Package created.

SQL> show errors
No errors.
SQL> 
SQL> @@COREMOD_API_BODY.SQL
SQL> CREATE OR REPLACE
  2  package body COREMOD_API as
  3  
  4    type t_lops_rec is record(
  5  	 g_rindex    BINARY_INTEGER,
  6  	 g_slno      BINARY_INTEGER,
  7  	 g_totalwork number,
  8  	 g_sofar     number,
  9  	 g_obj	     BINARY_INTEGER,
 10  	 g_op_name   varchar2(100),
 11  	 g_target_desc varchar2(100),
 12  	 g_units     varchar2(100)
 13    );
 14  
 15    type t_lops_tab is table of t_lops_rec index by pls_integer;
 16  
 17    g_lops_tab t_lops_tab;
 18    g_lops_idx number := 0;
 19  
 20    -- lock handle
 21    g_handle varchar2(512);
 22  
 23    function getMODNAME return varchar2 is begin return gMODNAME; end;
 24  
 25    procedure register(p_modname opas_modules.MODNAME%type,
 26  			  p_moddescr opas_modules.MODDESCR%type default null,
 27  			  p_modver opas_modules.MODVER%type,
 28  			  p_installed opas_modules.INSTALLED%type default sysdate)
 29    is
 30    begin
 31  	 merge into opas_modules t using (select p_modname modname, p_moddescr moddescr, p_modver modver, p_installed installed from dual) s
 32  	 on (t.modname = s.modname)
 33  	 when matched then update set
 34  	   t.moddescr = nvl(s.moddescr,t.moddescr),
 35  	   t.modver = s.modver,
 36  	   t.installed = s.installed
 37  	 when not matched then insert
 38  	   (t.modname, t.moddescr, t.modver, t.installed)
 39  	 values
 40  	   (s.modname, s.moddescr, s.modver, s.installed);
 41  	 commit;
 42    end;
 43  
 44    procedure init_longops(p_op_name varchar2, p_target_desc varchar2, p_units varchar2, p_totalwork number, p_lops_ind out pls_integer)
 45    is
 46    begin
 47  	 g_lops_idx:=g_lops_idx+1;
 48  
 49  	 g_lops_tab(g_lops_idx).g_op_name     := p_op_name;
 50  	 g_lops_tab(g_lops_idx).g_target_desc := p_target_desc;
 51  	 g_lops_tab(g_lops_idx).g_units       := p_units;
 52  
 53  	 g_lops_tab(g_lops_idx).g_rindex      := dbms_application_info.set_session_longops_nohint;
 54  	 g_lops_tab(g_lops_idx).g_sofar       := 0;
 55  	 g_lops_tab(g_lops_idx).g_totalwork   := p_totalwork;
 56  	 dbms_application_info.set_session_longops(g_lops_tab(g_lops_idx).g_rindex,
 57  						   g_lops_tab(g_lops_idx).g_slno,
 58  						   g_lops_tab(g_lops_idx).g_op_name,
 59  						   g_lops_tab(g_lops_idx).g_obj,
 60  						   0,
 61  						   g_lops_tab(g_lops_idx).g_sofar,
 62  						   g_lops_tab(g_lops_idx).g_totalwork,
 63  						   g_lops_tab(g_lops_idx).g_target_desc,
 64  						   g_lops_tab(g_lops_idx).g_units);
 65  
 66  	 p_lops_ind:=g_lops_idx;
 67    end;
 68  
 69    procedure start_longops_section(p_module_name varchar2, p_action_name varchar2)
 70    is
 71    begin
 72  	 DBMS_APPLICATION_INFO.SET_MODULE ( module_name => p_module_name, action_name => p_action_name);
 73  	 coremod_tasks.log(rtrim(p_module_name||'/'||p_action_name,'/'));
 74    end;
 75  
 76    procedure end_longops_section(p_sofar number default 1, p_lops_ind pls_integer)
 77    is
 78    begin
 79  	 if p_sofar = 1 then
 80  	   g_lops_tab(p_lops_ind).g_sofar := g_lops_tab(p_lops_ind).g_sofar + p_sofar;
 81  	 else
 82  	   g_lops_tab(p_lops_ind).g_sofar := p_sofar;
 83  	 end if;
 84  	 dbms_application_info.set_session_longops(g_lops_tab(p_lops_ind).g_rindex,
 85  						   g_lops_tab(p_lops_ind).g_slno,
 86  						   g_lops_tab(p_lops_ind).g_op_name,
 87  						   g_lops_tab(p_lops_ind).g_obj,
 88  						   0,
 89  						   g_lops_tab(p_lops_ind).g_sofar,
 90  						   g_lops_tab(p_lops_ind).g_totalwork,
 91  						   g_lops_tab(p_lops_ind).g_target_desc,
 92  						   g_lops_tab(p_lops_ind).g_units);
 93    end;
 94  
 95    function getconf(p_key varchar2, p_module opas_modules.modname%type) return varchar2 RESULT_CACHE
 96    is
 97  	 l_res opas_config.cvalue%type;
 98    begin
 99  	 select cvalue into l_res from opas_config where ckey=p_key and modname=p_module;
100  	 return l_res;
101    end;
102  
103  /*
104    function getscript(p_script_id varchar2) return clob
105    is
106  	 l_res clob;
107    begin
108  	 select script_content into l_res from opas_scripts where script_id=p_script_id;
109  	 return l_res;
110    exception
111  	 when no_data_found then raise_application_error(-20000,'Script "'||p_script_id||'" not found.');
112    end;
113  */
114    function getmodver(p_module opas_modules.modname%type) return varchar2 RESULT_CACHE
115    is
116  	 l_res opas_config.cvalue%type;
117    begin
118  	 select modver into l_res from opas_modules where modname=p_module;
119  	 return l_res;
120    end;
121  
122    procedure register_dblink(p_db_link_name varchar2,
123  				 p_owner varchar2,
124  				 p_is_public varchar2,
125  				 p_username varchar2,
126  				 p_password varchar2,
127  				 p_connectstring varchar2)
128    is
129    begin
130  	 insert into opas_db_links
131  	   (DB_LINK_NAME,OWNER,STATUS,is_public,username,password,connstr)
132  	 values
133  	   (upper(p_db_link_name), upper(p_owner),
134  	    dblNEW, case when upper(p_owner)='PUBLIC' then 'Y' else case when p_is_public = 'Y' then 'Y' else 'N' end end, p_username,p_password,p_connectstring);
135    end;
136  
137    procedure edit_dblink	(p_db_link_name varchar2,
138  				 p_is_public varchar2,
139  				 p_username varchar2,
140  				 p_password varchar2,
141  				 p_connectstring varchar2)
142    is
143  	 l_dblink opas_db_links%rowtype;
144    begin
145  	 select * into l_dblink from opas_db_links where DB_LINK_NAME = upper(p_db_link_name) for update nowait;
146  
147  	 if nvl(p_username,'~^')<>nvl(l_dblink.username,'~^') or
148  	    nvl(p_password,'~^')<>nvl(l_dblink.password,'~^') or
149  	    nvl(p_connectstring,'~^')<>nvl(l_dblink.connstr,'~^')
150  	 then
151  	   update opas_db_links set
152  		  STATUS = dblMODIFIED,
153  		  is_public = case when upper(owner)='PUBLIC' then 'Y' else case when p_is_public = 'Y' then 'Y' else 'N' end end,
154  		  username = p_username,
155  		  password = nvl(p_password,password),
156  		  connstr = p_connectstring
157  	    where DB_LINK_NAME = upper(p_db_link_name);
158  	  else
159  	   update opas_db_links set
160  		  is_public = case when upper(owner)='PUBLIC' then 'Y' else case when p_is_public = 'Y' then 'Y' else 'N' end end
161  	    where DB_LINK_NAME = upper(p_db_link_name);
162  	 end if;
163    end;
164  
165    procedure create_dblink(p_db_link_name varchar2, p_recreate boolean default false)
166    is
167  	 l_dblink opas_db_links%rowtype;
168    begin
169  	 if p_db_link_name=gDefaultSource then
170  	   raise_application_error(-20000, gDefaultSource||' db link is not supposed to be created.');
171  	 else
172  	   select * into l_dblink from opas_db_links where DB_LINK_NAME = upper(p_db_link_name) for update nowait;
173  	   if p_recreate then
174  	     declare
175  	       l_domain varchar2(128);
176  	     begin
177  	       select value into l_domain from v$parameter where name like '%domain%';
178  	       execute immediate 'drop database link ' || case when l_domain is null then p_db_link_name else p_db_link_name ||'.'|| l_domain end;
179  	     exception
180  	       when others then
181  		 COREMOD_LOG.log(DBMS_UTILITY.FORMAT_ERROR_STACK);
182  		 COREMOD_LOG.log(DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
183  		 COREMOD_LOG.log(sqlerrm);
184  	     end;
185  	   end if;
186  	     execute immediate q'[CREATE DATABASE LINK ]'||l_dblink.db_link_name||q'[ CONNECT TO ]'||l_dblink.username||q'[ IDENTIFIED BY ]'||l_dblink.password||q'[ USING ']'||l_dblink.connstr||q'[']';
187  	   update opas_db_links set STATUS=dblCREATED where DB_LINK_NAME=upper(p_db_link_name);
188  	   commit;
189  	 end if;
190    end;
191  
192    procedure drop_dblink(p_db_link_name varchar2, p_suspend boolean default false)
193    is
194  	 l_domain varchar2(128);
195  	 l_cnt number;
196    begin
197  	 if p_db_link_name=gDefaultSource then
198  	   raise_application_error(-20000, gDefaultSource||' db link is not supposed to be created.');
199  	 else
200  	   select value into l_domain from v$parameter where name like '%domain%';
201  	   select count(1) into l_cnt from user_db_links where db_link = upper(case when l_domain is null then p_db_link_name else p_db_link_name ||'.'|| l_domain end);
202  	   if l_cnt>0 then
203  	     begin
204  	       if p_suspend then
205  		 update opas_db_links set STATUS=dblSUSPENDED where DB_LINK_NAME=upper(p_db_link_name);
206  	       else
207  		 update opas_db_links set STATUS=dblTODELETE where DB_LINK_NAME=upper(p_db_link_name);
208  	       end if;
209  	       execute immediate 'drop database link ' || case when l_domain is null then p_db_link_name else p_db_link_name ||'.'|| l_domain end;
210  	     exception
211  	       when others then
212  		 COREMOD_LOG.log(DBMS_UTILITY.FORMAT_ERROR_STACK);
213  		 COREMOD_LOG.log(DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
214  		 COREMOD_LOG.log(sqlerrm);
215  		 raise;
216  	     end;
217  	   end if;
218  	   if not p_suspend then
219  	     delete from opas_db_links where DB_LINK_NAME=upper(p_db_link_name);
220  	   end if;
221  	   commit;
222  	 end if;
223    end;
224  
225    procedure test_dblink(p_db_link_name varchar2)
226    is
227  	 l_dblink varchar2(512);
228  	 l_status OPAS_DB_LINKS.status%type;
229  	 a number;
230    begin
231  	 select ora_db_link, status into l_dblink, l_status from V$OPAS_DB_LINKS where db_link_name=upper(p_db_link_name);
232  	 if l_status = dblSUSPENDED then raise_application_error(-20999, 'DB Link: '||p_db_link_name||' is suspended');end if;
233  	 begin
234  	   execute immediate 'select 1 from dual@'||l_dblink into a;
235  	 exception
236  	   when others then drop_dblink(p_db_link_name, p_suspend => true);
237  	   raise;
238  	 end;
239    end;
240  
241    function get_ora_dblink(p_db_link_name varchar2) return varchar2
242    is
243  	 l_dblink varchar2(512);
244    begin
245  	 select ora_db_link into l_dblink from V$OPAS_DB_LINKS where db_link_name=upper(p_db_link_name);
246  	 return l_dblink;
247    end;
248  
249    function get_def_source return varchar2 is begin return gDefaultSource; end;
250    function get_def_owner return varchar2 is begin return gDefaultOwner; end;
251  
252  
253    function lock_resource(p_resource_name varchar2, p_mode number default DBMS_LOCK.X_MODE, p_timeout number default 0, p_release_on_commit boolean default true) return varchar2
254    is
255  	 l_res	  integer;
256    begin
257  	 DBMS_LOCK.ALLOCATE_UNIQUE (
258  	   lockname	    => 'OPAS'||p_resource_name,
259  	   lockhandle	    => g_handle);
260  
261  	 l_res:=DBMS_LOCK.REQUEST(
262  	   lockhandle	      => g_handle,
263  	   lockmode	      => p_mode,
264  	   timeout	      => p_timeout,
265  	   release_on_commit  => p_release_on_commit);
266  
267  	 if l_res <> 0 then
268  	   raise_application_error(-20000, 'Resource '||p_resource_name||' can not be locked right now. Return code: '||l_res);
269  	 end if;
270  
271  	 return g_handle;
272    end;
273  
274    procedure lock_resource(p_resource_name varchar2, p_mode number default DBMS_LOCK.X_MODE, p_timeout number default 0, p_release_on_commit boolean default true)
275    is
276  	 l_handle varchar2(512);
277    begin
278  	 l_handle:=lock_resource(p_resource_name,p_mode,p_timeout,p_release_on_commit);
279    end;
280  
281    procedure release_resource(p_handle varchar2)
282    is
283  	 l_res integer;
284    begin
285  	 l_res := DBMS_LOCK.RELEASE(p_handle);
286    end;
287  
288    procedure release_resource
289    is
290    begin
291  	 release_resource(g_handle);
292    end;
293  
294  end COREMOD_API;
295  /

Package body created.

SQL> show errors
No errors.
SQL> 
SQL> @@COREMOD_LOG_BODY.SQL
SQL> CREATE OR REPLACE
  2  package body COREMOD_LOG is
  3  
  4    g_user_expirience_id varchar2(100);
  5  
  6    procedure debug_on
  7    is
  8    begin
  9  	 UPDATE opas_config
 10  	    SET cvalue = 'DEBUG'
 11  	  WHERE modname = COREMOD_API.gMODNAME
 12  	    AND cgroup = 'LOGGING'
 13  	    AND ckey = 'LOGGING_LEVEL';
 14    end;
 15  
 16    procedure debug_off
 17    is
 18    begin
 19  	 UPDATE opas_config
 20  	    SET cvalue = 'INFO'
 21  	  WHERE modname = COREMOD_API.gMODNAME
 22  	    AND cgroup = 'LOGGING'
 23  	    AND ckey = 'LOGGING_LEVEL';
 24    end;
 25  
 26    procedure log(p_msg clob, p_loglevel varchar2 default 'INFO')
 27    is
 28  	 l_level varchar2(100):=COREMOD_API.getconf('LOGGING_LEVEL',COREMOD_API.gMODNAME);
 29    begin
 30  	 if (l_level='INFO' and p_loglevel='INFO') or
 31  	    (l_level='DEBUG' and p_loglevel in ('INFO', 'DEBUG'))
 32  	 then
 33  	   coremod_tasks.log(p_msg);
 34  	 end if;
 35    end;
 36  
 37    procedure cleanup_logs
 38    is
 39  	 l_rows_processed number;
 40    begin
 41  	 delete from opas_log where created < sysdate-to_number(COREMOD_API.getconf('LOGRETENTION',COREMOD_API.gMODNAME));
 42  	 l_rows_processed:=sql%rowcount;
 43  	 commit;
 44  	 coremod_log.log('Cleanup logs: deleted '||l_rows_processed||' log row(s).');
 45    end;
 46  
 47    procedure Start_SQL_GATHER_STAT(p_name varchar2)
 48    is
 49    begin
 50  	 if nvl(coremod_api.getconf('INSTR_SQL_GATHER_STAT',COREMOD_API.gMODNAME),'~^') = p_name then
 51  	   execute immediate 'alter session set statistics_level=all';
 52  	   coremod_log.log('Start_SQL_GATHER_STAT: '||coremod_api.getconf('INSTR_SQL_GATHER_STAT',COREMOD_API.gMODNAME));
 53  	 end if;
 54    end;
 55  
 56    procedure Stop_SQL_GATHER_STAT(p_name varchar2)
 57    is
 58    begin
 59  	 if nvl(coremod_api.getconf('INSTR_SQL_GATHER_STAT',COREMOD_API.gMODNAME),'~^') = p_name then
 60  	   execute immediate 'alter session set statistics_level=TYPICAL';
 61  	   coremod_log.log('Stop_SQL_GATHER_STAT: '||coremod_api.getconf('INSTR_SQL_GATHER_STAT',COREMOD_API.gMODNAME));
 62  	 end if;
 63    end;
 64  
 65    procedure Start_SQL_TRACE(p_name varchar2)
 66    is
 67  	 l_trc_file varchar(4000);
 68    begin
 69  	 if nvl(coremod_api.getconf('INSTR_SQL_TRACE',COREMOD_API.gMODNAME),'~^') = p_name then
 70  	   select value into l_trc_file from v$diag_info where name = 'Default Trace File';
 71  	   g_user_expirience_id := sys_guid();
 72  	   coremod_log.log('Start_SQL_TRACE: '||coremod_api.getconf('INSTR_SQL_TRACE',COREMOD_API.gMODNAME)||'; EXPIRIENCE ID: '||nvl(g_user_expirience_id,'N/A'));
 73  	   coremod_log.log('Trace file: '||l_trc_file);
 74  	   execute immediate q'[begin DBMS_SESSION.SESSION_TRACE_ENABLE(]'||nvl(coremod_api.getconf('INSTR_SQL_TRACE_PARAMS',COREMOD_API.gMODNAME),q'[TRUE,TRUE,'FIRST_EXECUTION']')||q'[); end;]';
 75  	   dbms_log.ksdwrt(1, '*** EXPERIENCE ID:('||g_user_expirience_id||'-'||p_name||'-START)');
 76  	 end if;
 77    end;
 78  
 79    procedure Stop_SQL_TRACE(p_name varchar2)
 80    is
 81    begin
 82  	 if nvl(coremod_api.getconf('INSTR_SQL_TRACE',COREMOD_API.gMODNAME),'~^') = p_name then
 83  	   dbms_log.ksdwrt(1, '*** EXPERIENCE ID:('||nvl(g_user_expirience_id,'N/A')||'-'||p_name||'-END)');
 84  	   DBMS_SESSION.SESSION_TRACE_DISABLE;
 85  	   coremod_log.log('Stop_SQL_TRACE: '||coremod_api.getconf('INSTR_SQL_TRACE',COREMOD_API.gMODNAME)||'; EXPIRIENCE ID: '||nvl(g_user_expirience_id,'N/A'));
 86  	 end if;
 87    end;
 88  
 89  end;
 90  /

Package body created.

SQL> show errors
No errors.
SQL> 
SQL> @@COREMOD_SEC_BODY.SQL
SQL> CREATE OR REPLACE
  2  package body COREMOD_SEC as
  3  
  4    function is_mod_installed(p_modname opas_modules.MODNAME%type) return boolean RESULT_CACHE
  5    is
  6  	 l_cnt number;
  7    begin
  8  	 select count(1) into l_cnt from opas_modules where MODNAME=p_modname;
  9  	 return l_cnt>0;
 10    end;
 11  
 12    function is_role_assigned(p_modname OPAS_GROUPS2APEXUSR.modname%type, p_group_name opas_groups.group_name%type) return boolean
 13    is
 14  	 l_ual number;
 15  	 l_gal number;
 16    begin
 17  	 select min(group_id) into l_ual
 18  	   from OPAS_GROUPS2APEXUSR g2u
 19  	  where g2u.apex_user = V('APP_USER')
 20  	    and g2u.modname=p_modname;
 21  
 22  	 select group_id into l_gal from opas_groups where group_name=p_group_name;
 23  	 --user access level less or eqial to group access level
 24  	 return l_gal>=l_ual;
 25    end;
 26  
 27    function is_role_assigned_n(p_modname OPAS_GROUPS2APEXUSR.modname%type, p_group_name opas_groups.group_name%type) return number
 28    is
 29    begin
 30  	 return case when is_role_assigned(p_modname,p_group_name) then 1 else 0 end;
 31    end;
 32  
 33    procedure save_role_assignment(p_modname_lst t_mod_list, p_group_id_lst t_grp_id_list, p_apex_user OPAS_GROUPS2APEXUSR.apex_user%type)
 34    is
 35  	 l_handle varchar2(512);
 36    begin
 37  	 if p_modname_lst.count<>p_group_id_lst.count then
 38  	   raise_application_error(-20000,'Invalid lists of modules and groups specified.');
 39  	 end if;
 40  
 41  	 if p_modname_lst.count>0 then
 42  	   l_handle:=COREMOD_API.lock_resource('SETUSERPERM'||p_apex_user);
 43  
 44  	   for i in 1..p_modname_lst.count loop
 45  	     delete from OPAS_GROUPS2APEXUSR
 46  	      where apex_user=p_apex_user
 47  		and modname=p_modname_lst(i);
 48  	     if p_group_id_lst(i) is not null then
 49  	       insert into OPAS_GROUPS2APEXUSR (group_id, modname, apex_user) values (p_group_id_lst(i),p_modname_lst(i), p_apex_user);
 50  	     end if;
 51  	   end loop;
 52  	   COREMOD_API.release_resource(l_handle);
 53  	 end if;
 54    end;
 55  
 56  /*
 57    function proj_is_role_assigned(p_proj_type opas_project_types.proj_type%type, p_group_name opas_groups.group_name%type) return boolean
 58    is
 59  	 l_modname opas_project_types.modname%type;
 60    begin
 61  	 if p_proj_type is null then
 62  	   return false;
 63  	 end if;
 64  	 select modname into l_modname from opas_project_types where proj_type = p_proj_type;
 65  	 return is_role_assigned(l_modname,p_group_name);
 66    exception
 67  	 when no_data_found then
 68  	   return false;
 69    end;
 70  */
 71  end COREMOD_SEC;
 72  /

Package body created.

SQL> show errors
No errors.
SQL> 
SQL> @@COREMOD_TASKS_BODY.SQL
SQL> CREATE OR REPLACE
  2  package body coremod_tasks as
  3  
  4    g_time number;
  5    g_cpu_tim number;
  6  
  7    gJOBNMPREF   constant varchar2(10):='OPASTASK';
  8  
  9    gTQ_ID	    number;
 10  
 11    function get_curr_tq_id return opas_task_queue.tq_id%type is begin return gTQ_ID; end;
 12  
 13    procedure log(p_msg opas_log.msg%type, p_tq_id opas_task_queue.tq_id%type default null)
 14    is
 15  	 PRAGMA AUTONOMOUS_TRANSACTION;
 16    begin
 17  	 if length(p_msg)<=4000 then
 18  	   insert into opas_log (created, msg, tq_id) values (default, p_msg, nvl(p_tq_id,gTQ_ID));
 19  	 else
 20  	   insert into opas_log (created, msg_long, tq_id) values (default, p_msg, nvl(p_tq_id,gTQ_ID));
 21  	 end if;
 22  	 commit;
 23    end;
 24  
 25    procedure cleanup_tasks is
 26  	 l_rows_processed number;
 27    begin
 28  	 delete from opas_task_queue
 29  	  where (systimestamp - finished > TO_DSINTERVAL(COREMOD_API.getconf('TASKRETENTION',COREMOD_API.gMODNAME)||' 00:00:00'))
 30  	     or (status = gtqRUNNING and started<sysdate-0.95 and nvl(job_name,'~^') not in (select job_name from user_scheduler_running_jobs))
 31  	     or  status = gtqCanceled;
 32  	 l_rows_processed:=sql%rowcount;
 33  	 commit;
 34  	 coremod_log.log('Cleanup task queue: deleted '||l_rows_processed||' row(s).');
 35    end;
 36  
 37  
 38    procedure create_task(p_taskname   opas_task.taskname%type,
 39  			     p_modname	  opas_task.modname%type,
 40  			     p_is_public  opas_task.is_public%type default 'Y',
 41  			     p_task_priority opas_task.task_priority%type,
 42  			     p_task_body  opas_task.task_body%type)
 43    is
 44    begin
 45  	 INSERT INTO opas_task (taskname, modname, is_public, created, task_body, task_priority)
 46  			VALUES (upper(p_taskname),p_modname,p_is_public,default,p_task_body, p_task_priority);
 47    end;
 48  
 49  
 50    function prep_execute_task(p_taskname opas_task.taskname%type,
 51  				  p_task_subname opas_task_queue.task_subname%type default null) return opas_task_queue.tq_id%type
 52    is
 53  	 l_tq_id opas_task_queue.tq_id%type;
 54    begin
 55  	 INSERT INTO opas_task_queue (taskname, owner, status, task_subname) VALUES (p_taskname, nvl(V('APP_USER'),'PUBLIC'), gtqNEW, p_task_subname) returning tq_id into l_tq_id;
 56  	 return l_tq_id;
 57    end;
 58  
 59    procedure set_task_param(p_tq_id opas_task_queue.tq_id%type, p_name opas_task_pars.par_name%type, p_num_par number)
 60    is
 61    begin
 62  	 merge into OPAS_TASK_PARS t using (select p_tq_id id, p_name nm, p_num_par val from dual) s
 63  	 on (t.tq_id = s.id and t.par_name=s.nm)
 64  	 when matched then update set num_par = s.val
 65  	 when not matched then insert (tq_id,par_name,num_par) values (s.id, s.nm, s.val);
 66    end;
 67  
 68    procedure set_task_param(p_tq_id opas_task_queue.tq_id%type, p_name opas_task_pars.par_name%type, p_varchar_par varchar2)
 69    is
 70    begin
 71  	 merge into OPAS_TASK_PARS t using (select p_tq_id id, p_name nm, p_varchar_par val from dual) s
 72  	 on (t.tq_id = s.id and t.par_name=s.nm)
 73  	 when matched then update set varchar_par = s.val
 74  	 when not matched then insert (tq_id,par_name,varchar_par) values (s.id, s.nm, s.val);
 75    end;
 76  
 77    procedure set_task_param(p_tq_id opas_task_queue.tq_id%type, p_name opas_task_pars.par_name%type, p_date_par date)
 78    is
 79    begin
 80  	 merge into OPAS_TASK_PARS t using (select p_tq_id id, p_name nm, p_date_par val from dual) s
 81  	 on (t.tq_id = s.id and t.par_name=s.nm)
 82  	 when matched then update set date_par = s.val
 83  	 when not matched then insert (tq_id,par_name,date_par) values (s.id, s.nm, s.val);
 84    end;
 85  
 86    procedure set_task_param_list(p_tq_id opas_task_queue.tq_id%type, p_name opas_task_pars.par_name%type, p_list_par varchar2)
 87    is
 88    begin
 89  	 merge into OPAS_TASK_PARS t using (select p_tq_id id, p_name nm, p_list_par val from dual) s
 90  	 on (t.tq_id = s.id and t.par_name=s.nm)
 91  	 when matched then update set list_par = s.val
 92  	 when not matched then insert (tq_id,par_name,list_par) values (s.id, s.nm, s.val);
 93    end;
 94  
 95    procedure queue_task(p_tq_id opas_task_queue.tq_id%type, p_start_time date default null)
 96    is
 97  	 l_task_name opas_task_queue.taskname%type;
 98  	 l_job_name  opas_task_queue.job_name%type;
 99    begin
100  	 if p_start_time is null then
101  	   update opas_task_queue set status=gtqQUEUED, queued=systimestamp where tq_id = p_tq_id and status=gtqNEW returning taskname into l_task_name;
102  	   if sql%rowcount<1 then
103  	     raise_application_error(-20000,'Unable to change task status ID, Status: '||p_tq_id||', '||gtqQUEUED);
104  	   end if;
105  	 else
106  	   select taskname into l_task_name from opas_task_queue where tq_id = p_tq_id;
107  
108  	   l_job_name := gJOBNMPREF||'_'||upper(l_task_name)||'_'||DBMS_RANDOM.STRING('X',6);
109  
110  	   update opas_task_queue set status=gtqSCHEDULED, queued=systimestamp, job_name = l_job_name where tq_id = p_tq_id and status=gtqNEW;
111  	   if sql%rowcount<1 then
112  	     raise_application_error(-20000,'Unable to change task status ID, Status: '||p_tq_id||', '||gtqQUEUED);
113  	   end if;
114  
115  	   dbms_scheduler.create_job(job_name => l_job_name,
116  				     job_type => 'PLSQL_BLOCK',
117  				     job_action => 'begin coremod_tasks.execute_task('||p_tq_id||'); end;',
118  				     start_date => p_start_time,
119  				     enabled => true,
120  				     auto_drop=> true);
121  	 end if;
122    end;
123  
124    procedure cancel_task(p_tq_id opas_task_queue.tq_id%type)
125    is
126  	 l_job_name  opas_task_queue.job_name%type;
127    begin
128  	 update opas_task_queue set status=gtqCanceled where tq_id = p_tq_id and status in (gtqNEW,gtqQUEUED,gtqSCHEDULED) returning job_name into l_job_name;
129  	 if sql%rowcount<1 then
130  	   raise_application_error(-20000,'Unable to change task status ID, Status: '||p_tq_id||', '||gtqCanceled);
131  	 end if;
132  	 if l_job_name is not null then
133  	   dbms_scheduler.disable(l_job_name);
134  	   dbms_scheduler.drop_job(l_job_name);
135  	 end if;
136    exception
137  	 when others then
138  	   log('cancel_task error: '||sqlerrm,p_tq_id);
139    end;
140  
141  
142    procedure set_task_started(p_tq_id opas_task_queue.tq_id%type, p_job_name opas_task_queue.job_name%type)
143    is
144    begin
145  	 update opas_task_queue set status=gtqSTARTED, job_name = p_job_name where tq_id = p_tq_id and status in (gtqQUEUED);
146  	 if sql%rowcount<1 then
147  	   raise_application_error(-20000,'Unable to change task status ID, Status: '||p_tq_id||', '||gtqSTARTED);
148  	 end if;
149    end;
150  
151    procedure set_task_running(p_tq_id opas_task_queue.tq_id%type)
152    is
153  	 PRAGMA AUTONOMOUS_TRANSACTION;
154    begin
155  	 g_time:=DBMS_UTILITY.GET_TIME;
156  	 g_cpu_tim:=DBMS_UTILITY.GET_CPU_TIME;
157  	 update opas_task_queue set
158  		started=systimestamp,
159  		sid=SYS_CONTEXT('USERENV','SID'),
160  		serial#=(select serial# from gv$session where sid=SYS_CONTEXT('USERENV','SID') and inst_id=SYS_CONTEXT('USERENV','INSTANCE')),
161  		inst_id=SYS_CONTEXT('USERENV','INSTANCE'),
162  		status=gtqRUNNING
163  	  where tq_id=p_tq_id and status in (gtqSTARTED, gtqSCHEDULED);
164  	 if sql%rowcount<1 then
165  	   raise_application_error(-20000,'Unable to change task status ID, Status: '||p_tq_id||', '||gtqRUNNING);
166  	 end if;
167  	 commit;
168    exception
169  	 when others then
170  	   rollback;
171  	   raise;
172    end;
173    procedure set_task_finished(p_tq_id opas_task_queue.tq_id%type, p_status opas_task_queue.status%type)
174    is
175  	 PRAGMA AUTONOMOUS_TRANSACTION;
176    begin
177  	   g_time:=DBMS_UTILITY.GET_TIME-g_time;
178  	   g_cpu_tim:=DBMS_UTILITY.GET_CPU_TIME-g_cpu_tim;
179  	   update opas_task_queue set
180  		  finished=systimestamp,
181  		  cpu_time=g_cpu_tim/100,
182  		  elapsed_time=g_time/100,
183  		  status=p_status
184  	    where tq_id=p_tq_id and status in (gtqRUNNING);
185  	 if sql%rowcount<1 then
186  	   raise_application_error(-20000,'Unable to change task status ID, Status: '||p_tq_id||', '||p_status);
187  	 end if;
188  	 commit;
189    exception
190  	 when others then
191  	   rollback;
192  	   raise;
193    end;
194  
195    procedure execute_task_proc is  --job coordinator
196  	 --l_running_jobs number;
197  	 l_freeslots	number;
198  	 type t_task_tbl is table of opas_task_queue%rowtype;
199  	 l_tasks   t_task_tbl;
200  	 l_2run    t_task_tbl := t_task_tbl();
201    begin
202  	 for i in (select t.task_priority, count(1) cnt
203  		     from USER_SCHEDULER_RUNNING_JOBS j, opas_task_queue tq, opas_task t
204  		    where j.job_name like gJOBNMPREF||'%'
205  		      and j.job_name = tq.job_name
206  		      and tq.taskname = t.taskname)
207  	 loop
208  	   if i.cnt < to_number(COREMOD_API.getconf('MAXTHREADS'||i.task_priority,COREMOD_API.gMODNAME)) then
209  	     l_freeslots:= to_number(COREMOD_API.getconf('MAXTHREADS'||i.task_priority,COREMOD_API.gMODNAME)) - i.cnt;
210  
211  	     select tq.* bulk collect into l_tasks
212  	       from opas_task_queue tq, opas_task t
213  	      where status=gtqQUEUED
214  		and tq.taskname = t.taskname
215  		and t.task_priority = i.task_priority
216  		for update skip locked order by queued;
217  
218  	     for i in 1..least(l_freeslots,l_tasks.count) loop
219  	       l_2run.extend;
220  	       l_2run(l_2run.count):=l_tasks(i);
221  	       l_2run(l_2run.count).job_name:=gJOBNMPREF||'_'||upper(l_2run(l_2run.count).taskname)||'_'||DBMS_RANDOM.STRING('X',6);
222  	       set_task_started(l_tasks(i).tq_id, l_2run(l_2run.count).job_name);
223  	     end loop;
224  	   end if;
225  	 end loop;
226  	 commit;
227  
228  	 for i in 1..l_2run.count
229  	 loop
230  	   begin
231  	     dbms_scheduler.create_job(job_name => l_2run(i).job_name,
232  				       job_type => 'PLSQL_BLOCK',
233  				       job_action => 'begin coremod_tasks.execute_task('||l_2run(i).tq_id||'); end;',
234  				       start_date => systimestamp,
235  				       enabled => true,
236  				       auto_drop=> true);
237  	   exception
238  	     when others then
239  	       log('Execute task error: '||sqlerrm,l_2run(i).tq_id);
240  	       log(DBMS_UTILITY.FORMAT_ERROR_STACK,l_2run(i).tq_id);
241  	   end;
242  	 end loop;
243    end;
244  
245    procedure stop_task(p_tq_id opas_task_queue.tq_id%type)
246    is
247  	 l_job_name opas_task_queue.job_name%type;
248    begin
249  	 select job_name into l_job_name from opas_task_queue where tq_id=p_tq_id;
250  	 update opas_task_queue set status=gtqCanceled where tq_id = p_tq_id and status in (gtqRUNNING);
251  	 commit;
252  	 dbms_scheduler.stop_job(l_job_name, true);
253    exception
254  	  when others then
255  	    log('Stop job error: '||l_job_name||':'||p_tq_id||chr(10)||sqlerrm);
256  	    log(DBMS_UTILITY.FORMAT_ERROR_STACK);
257    end;
258  
259    procedure stop_previous_user_task(p_taskname   opas_task.taskname%type)
260    is
261    begin
262  	 for i in (select * from opas_task_queue where status=gtqRUNNING and owner = V('APP_USER') and taskname=p_taskname and job_name in (select job_name from user_scheduler_running_jobs)) loop
263  	   log('Stopping previous instance of '||p_taskname||' with job name: '||i.job_name);
264  	   stop_task(i.tq_id);
265  	 end loop;
266    end;
267  
268    procedure create_task_job is
269    begin
270  	 dbms_scheduler.create_program(
271  				   program_name 	    => 'OPAS_TASK_COORD_PRG',
272  				   program_type 	    => 'PLSQL_BLOCK',
273  				   program_action	    => 'begin coremod_tasks.execute_task_proc; end;',
274  				   enabled		    => true,
275  				   comments		    => 'OPAS Task job coordinator program');
276  	 dbms_scheduler.create_job(job_name		    => 'OPAS_TASK_COORD',
277  				   program_name 	    => 'OPAS_TASK_COORD_PRG',
278  				   start_date		    => trunc(systimestamp,'mi'),
279  				   repeat_interval	    => 'FREQ=SECONDLY; INTERVAL=10',
280  				   job_style		    => 'LIGHTWEIGHT',
281  				   job_class		    => 'JC_'||user,
282  				   enabled		    => true);
283    end;
284  
285    procedure execute_task(p_tq_id opas_task_queue.tq_id%type)
286    is
287  	 l_task opas_task%rowtype;
288  	 l_task_body clob;
289    begin
290  	 gTQ_ID:=p_tq_id;
291  	 set_task_running(p_tq_id);
292  	 select * into l_task from opas_task where taskname=(select taskname from opas_task_queue where tq_id = p_tq_id);
293  	 l_task_body:=l_task.task_body;
294  	 for i in (select * from opas_task_pars where tq_id = p_tq_id) loop
295  	   case
296  	     when i.num_par is not null then
297  	       l_task_body:=replace(l_task_body,'<'||i.par_name||'>',i.num_par);
298  	     when i.varchar_par is not null then
299  	       l_task_body:=replace(l_task_body,'<'||i.par_name||'>',q'[']'||i.varchar_par||q'[']');
300  	     when i.list_par is not null then
301  	       l_task_body:=replace(l_task_body,'<'||i.par_name||'>',i.list_par);
302  	     when i.date_par is not null then
303  	       raise_application_error(-20000,'Not implemented parameter type: DATE');
304  	     else
305  	       raise_application_error(-20000,'Null parameter passed');
306  	   end case;
307  	 end loop;
308  	 log('Start task: '||l_task.taskname,p_tq_id);
309  	 execute immediate l_task_body;
310  	 log('End task: '||l_task.taskname,p_tq_id);
311  	 set_task_finished(p_tq_id,gtqSUCCEEDED);
312  	 gTQ_ID:=null;
313    exception
314  	 when others then
315  	   set_task_finished(p_tq_id,gtqFAILED);
316  	   log('Execute task error ('||l_task.taskname||'): '||sqlerrm,p_tq_id);
317  	   log('Task body: '||l_task_body,p_tq_id);
318  	   log('Execute task error stack: '||DBMS_UTILITY.FORMAT_ERROR_STACK,p_tq_id);
319  	   gTQ_ID:=null;
320  	   raise_application_error(-20000, 'Execute task error ('||l_task.taskname||'): '||sqlerrm);
321    end;
322  
323  
324    procedure drop_task(p_taskname opas_task.taskname%type) is
325    begin
326  	 delete from opas_task where taskname=upper(p_taskname);
327  	 commit;
328    end;
329  
330  end;
331  /

Package body created.

SQL> show errors
No errors.
SQL> 
SQL> @@COREMOD_UTILS_BODY.SQL
SQL> CREATE OR REPLACE
  2  PACKAGE BODY COREMOD_UTILS AS
  3  
  4    function  lsttochr(p_list tableofnumbers) return varchar2
  5    is
  6  	 l_ret varchar2(4000);
  7    begin
  8  	 for i in 1..p_list.count loop
  9  	   l_ret:=l_ret||p_list(i)||',';
 10  	 end loop;
 11  	 return rtrim(l_ret,',');
 12    end;
 13  
 14    function bool2str(p_bool boolean) return varchar2
 15    is
 16    begin
 17  	 if p_bool is not null then
 18  	   if p_bool then return 'TRUE'; else return 'FALSE'; end if;
 19  	 else
 20  	   return 'NULL';
 21  	 end if;
 22    end;
 23  
 24    function clob2tab(p_file_id    opas_files.file_id%type) return clob_page pipelined
 25    as
 26  	   m_c1 	   clob;
 27  	   m_b1 	   blob;
 28  	   m_length	   number(12);
 29  
 30  	   l_eof       number;
 31  	   l_iter      number;
 32  	   l_off       number;
 33  
 34  	   l_chunk_off number := 1;
 35  	   l_chunk     varchar2(32765);
 36  
 37  	   l_lcntx     integer := DBMS_LOB.DEFAULT_LANG_CTX;
 38  	   l_wrng      integer;
 39    begin
 40  	   select file_contentb, length(file_contentb)
 41  	   into   m_b1, m_length
 42  	   from   opas_files
 43  	   where  file_id = p_file_id;
 44  
 45  	   DBMS_LOB.CONVERTTOCLOB(
 46  	     dest_lob	    => m_c1,
 47  	     src_blob	    => m_b1,
 48  	     amount	    => DBMS_LOB.LOBMAXSIZE,
 49  	     dest_offset    => l_off,
 50  	     src_offset     => l_off,
 51  	     blob_csid	    => DBMS_LOB.DEFAULT_CSID,
 52  	     lang_context   => l_lcntx,
 53  	     warning	    => l_wrng);
 54  
 55  	   if (m_c1 is null or m_length = 0) then
 56  	       pipe row(clob_line(1,to_char(null)));
 57  	   else
 58  	     l_iter:=1;
 59  	     m_c1:=m_c1||chr(10);
 60  	     loop
 61  	       l_chunk:=substr(m_c1,l_chunk_off,32765);
 62  	       l_chunk:=substr(l_chunk,1,instr(l_chunk,chr(10),-1));
 63  	       exit when nvl(length(l_chunk),0)=0;
 64  	       l_chunk_off:=l_chunk_off+length(l_chunk);
 65  	       l_off:=1;
 66  	       loop
 67  		 l_eof:=instr(l_chunk,chr(10),l_off);
 68  		 if l_eof=0 then
 69  		   pipe row (clob_line( l_iter, substr(rtrim(rtrim(substr(l_chunk,l_off),chr(13)),chr(10)),1,4000)));
 70  		 else
 71  		   pipe row (clob_line( l_iter, substr(rtrim(rtrim(substr(l_chunk,l_off,l_eof-l_off+1),chr(13)),chr(10)),1,4000)));
 72  		 end if;
 73  		 l_off:=1+l_eof;
 74  		 l_iter:=l_iter+1;
 75  		 exit when l_eof=0;
 76  	       end loop;
 77  	     end loop;
 78  	   end if;
 79  	   return;
 80    end;
 81  
 82  
 83    function get_remote_oracle_version(p_dblink opas_db_links.db_link_name%type) return number
 84    is
 85  	 l_sql	varchar2(1000) := q'[begin dbms_utility.db_version@]'||COREMOD_API.get_ora_dblink(p_dblink)||q'[(:a, :b); end;]';
 86  	 l_ver	varchar2(100);
 87  	 l_comp varchar2(100);
 88    begin
 89  	 execute immediate l_sql using out l_ver, out l_comp;
 90  	 return to_number(substr(l_ver,1,instr(l_ver,'.')-1));
 91    end;
 92  
 93  END COREMOD_UTILS;
 94  /

Package body created.

SQL> show errors
No errors.
SQL> 
SQL> 
SQL> exec COREMOD_API.register(p_modname => 'OPASAPP', p_moddescr => 'Oracle Performance Analytic Suite Application', p_modver => '&OPASVER.', p_installed => sysdate);

PL/SQL procedure successfully completed.

SQL> exec COREMOD_API.register(p_modname => '&MODNM.', p_moddescr => 'Core Module', p_modver => '&MODVER.', p_installed => sysdate);

PL/SQL procedure successfully completed.

SQL> 
SQL> 
SQL> @../modules/core/data/load.sql
SQL> insert into opas_db_links (DB_LINK_NAME,OWNER,STATUS,is_public) values ('$LOCAL$', 'PUBLIC', 'CREATED','Y');

1 row created.

SQL> 
SQL> 
SQL> INSERT INTO opas_config (modname,cgroup,ckey,cvalue,descr) VALUES ('&MODNM.','TASKEXEC','MAXTHREADSHIGH',4,'High priority: Max number of simultaneously running tasks');
old   1: INSERT INTO opas_config (modname,cgroup,ckey,cvalue,descr) VALUES ('&MODNM.','TASKEXEC','MAXTHREADSHIGH',4,'High priority: Max number of simultaneously running tasks')
new   1: INSERT INTO opas_config (modname,cgroup,ckey,cvalue,descr) VALUES ('OPASCORE','TASKEXEC','MAXTHREADSHIGH',4,'High priority: Max number of simultaneously running tasks')

1 row created.

SQL> INSERT INTO opas_config (modname,cgroup,ckey,cvalue,descr) VALUES ('&MODNM.','TASKEXEC','MAXTHREADSNORM',2,'Normal priority: Max number of simultaneously running tasks');
old   1: INSERT INTO opas_config (modname,cgroup,ckey,cvalue,descr) VALUES ('&MODNM.','TASKEXEC','MAXTHREADSNORM',2,'Normal priority: Max number of simultaneously running tasks')
new   1: INSERT INTO opas_config (modname,cgroup,ckey,cvalue,descr) VALUES ('OPASCORE','TASKEXEC','MAXTHREADSNORM',2,'Normal priority: Max number of simultaneously running tasks')

1 row created.

SQL> INSERT INTO opas_config (modname,cgroup,ckey,cvalue,descr) VALUES ('&MODNM.','TASKEXEC','MAXTHREADSLOW', 1,'Low priority: Max number of simultaneously running tasks');
old   1: INSERT INTO opas_config (modname,cgroup,ckey,cvalue,descr) VALUES ('&MODNM.','TASKEXEC','MAXTHREADSLOW', 1,'Low priority: Max number of simultaneously running tasks')
new   1: INSERT INTO opas_config (modname,cgroup,ckey,cvalue,descr) VALUES ('OPASCORE','TASKEXEC','MAXTHREADSLOW', 1,'Low priority: Max number of simultaneously running tasks')

1 row created.

SQL> INSERT INTO opas_config (modname,cgroup,ckey,cvalue,descr) VALUES ('&MODNM.','RETENTION','TASKRETENTION',3,'Retention time in days for task queue metadata.');
old   1: INSERT INTO opas_config (modname,cgroup,ckey,cvalue,descr) VALUES ('&MODNM.','RETENTION','TASKRETENTION',3,'Retention time in days for task queue metadata.')
new   1: INSERT INTO opas_config (modname,cgroup,ckey,cvalue,descr) VALUES ('OPASCORE','RETENTION','TASKRETENTION',3,'Retention time in days for task queue metadata.')

1 row created.

SQL> INSERT INTO opas_config (modname,cgroup,ckey,cvalue,descr) VALUES ('&MODNM.','RETENTION','LOGRETENTION', 3,'Retention time in days for logs.');
old   1: INSERT INTO opas_config (modname,cgroup,ckey,cvalue,descr) VALUES ('&MODNM.','RETENTION','LOGRETENTION', 3,'Retention time in days for logs.')
new   1: INSERT INTO opas_config (modname,cgroup,ckey,cvalue,descr) VALUES ('OPASCORE','RETENTION','LOGRETENTION', 3,'Retention time in days for logs.')

1 row created.

SQL> INSERT INTO opas_config (modname,cgroup,ckey,cvalue,descr) VALUES ('&MODNM.','INSTRUMENTATION','INSTR_SQL_GATHER_STAT',null,'Start to gather SQL rowsource statistic for a given code.');
old   1: INSERT INTO opas_config (modname,cgroup,ckey,cvalue,descr) VALUES ('&MODNM.','INSTRUMENTATION','INSTR_SQL_GATHER_STAT',null,'Start to gather SQL rowsource statistic for a given code.')
new   1: INSERT INTO opas_config (modname,cgroup,ckey,cvalue,descr) VALUES ('OPASCORE','INSTRUMENTATION','INSTR_SQL_GATHER_STAT',null,'Start to gather SQL rowsource statistic for a given code.')

1 row created.

SQL> INSERT INTO opas_config (modname,cgroup,ckey,cvalue,descr) VALUES ('&MODNM.','INSTRUMENTATION','INSTR_SQL_TRACE',null,'Start Extended SQL Trace for a given code.');
old   1: INSERT INTO opas_config (modname,cgroup,ckey,cvalue,descr) VALUES ('&MODNM.','INSTRUMENTATION','INSTR_SQL_TRACE',null,'Start Extended SQL Trace for a given code.')
new   1: INSERT INTO opas_config (modname,cgroup,ckey,cvalue,descr) VALUES ('OPASCORE','INSTRUMENTATION','INSTR_SQL_TRACE',null,'Start Extended SQL Trace for a given code.')

1 row created.

SQL> 
SQL> INSERT INTO opas_config (modname,cgroup,ckey,cvalue,descr) VALUES ('&MODNM.','LOGGING','LOGGING_LEVEL','INFO','Current logging level. INFO|DEBUG');
old   1: INSERT INTO opas_config (modname,cgroup,ckey,cvalue,descr) VALUES ('&MODNM.','LOGGING','LOGGING_LEVEL','INFO','Current logging level. INFO|DEBUG')
new   1: INSERT INTO opas_config (modname,cgroup,ckey,cvalue,descr) VALUES ('OPASCORE','LOGGING','LOGGING_LEVEL','INFO','Current logging level. INFO|DEBUG')

1 row created.

SQL> 
SQL> insert into opas_groups (group_id,group_name,group_descr) values (0, 'Administrators','Full set of rights');

1 row created.

SQL> insert into opas_groups (group_id,group_name,group_descr) values (1, 'Reas-write users','All application functions');

1 row created.

SQL> insert into opas_groups (group_id,group_name,group_descr) values (2, 'Read-only users','Read-only functions');

1 row created.

SQL> insert into opas_groups (group_id,group_name,group_descr) values (3, 'No access users','No access to any functionality');

1 row created.

SQL> 
SQL> 
SQL> @@expimp_compat
SQL> delete from opas_expimp_compat where modname='&MODNM.';
old   1: delete from opas_expimp_compat where modname='&MODNM.'
new   1: delete from opas_expimp_compat where modname='OPASCORE'

0 rows deleted.

SQL> INSERT INTO opas_expimp_compat ( modname, src_version, trg_version) VALUES ( '&MODNM.',  '&MODVER.',  '&MODVER.');
old   1: INSERT INTO opas_expimp_compat ( modname, src_version, trg_version) VALUES ( '&MODNM.',  '&MODVER.',  '&MODVER.')
new   1: INSERT INTO opas_expimp_compat ( modname, src_version, trg_version) VALUES ( 'OPASCORE',  '2.0.0',  '2.0.0')

1 row created.

SQL> ----
SQL> /*
SQL> INSERT INTO opas_config (modname,cgroup,ckey,cvalue,descr) VALUES ('&MODNM.','RETENTION','SQLCACHERETENTION', 30,'Retention time in days for SQL Cache.');
SQL> 
SQL> INSERT INTO opas_config (modname,cgroup,ckey,cvalue,descr) VALUES ('&MODNM.','REPORT','LONGSECTROWS', 10000,'Custom reports long sections length in rows');
SQL> INSERT INTO opas_config (modname,cgroup,ckey,cvalue,descr) VALUES ('&MODNM.','REPORT','NARROWSECT',   700,  'Custom reports narrow section width, pixels');
SQL> INSERT INTO opas_config (modname,cgroup,ckey,cvalue,descr) VALUES ('&MODNM.','REPORT','MIDDLESECT',   1000, 'Custom reports middle section width, pixels');
SQL> INSERT INTO opas_config (modname,cgroup,ckey,cvalue,descr) VALUES ('&MODNM.','REPORT','WIDESECT',	   1500, 'Custom reports wide section width, pixels');
SQL> INSERT INTO opas_config (modname,cgroup,ckey,cvalue,descr) VALUES ('&MODNM.','REPORT','SUPERWIDESECT',1800, 'Custom reports super wide section width, pixels');
SQL> 
SQL> INSERT INTO opas_config (modname,cgroup,ckey,cvalue,descr) VALUES ('&MODNM.','EXPIMP','EXPIMPDIR','&OPASEXPIMP_DIR.', 'Directory object for EXP/IMP operation');
SQL> INSERT INTO opas_config (modname,cgroup,ckey,cvalue,descr) VALUES ('&MODNM.','EXPIMP','EXPIMPVER','12.2', 'Compatibility level for EXP/IMP dump');
SQL> 
SQL> 
SQL> 
SQL> 
SQL> 
SQL> INSERT INTO
SQL>   opas_dictionary (modname,dic_name,val,display_val,sparse1,sparse2,sparse3,dic_ordr)
SQL> 		VALUES ('&MODNM.','REPORT_TYPES','CUST_AWRCOMP' 	  ,'AWR query plan compare report (custom)'   ,157,null,null,10);
SQL> 
SQL> INSERT INTO
SQL>   opas_dictionary (modname,dic_name,val,display_val,sparse1,sparse2,sparse3,dic_ordr)
SQL> 		VALUES ('&MODNM.','REPORT_TYPES','CUST_SQLMULTIPLAN'	  ,'Analyze SQLs with multiple plans (custom)',158,null,null,20);
SQL> 
SQL> INSERT INTO
SQL>   opas_dictionary (modname,dic_name,val,display_val,sparse1,sparse2,sparse3,dic_ordr)
SQL> 		VALUES ('&MODNM.','REPORT_TYPES','CUST_SQL_AWR_REPORT'	  ,'AWR SQL report (custom)'		      ,151,null,null,10);
SQL> INSERT INTO
SQL>   opas_dictionary (modname,dic_name,val,display_val,sparse1,sparse2,sparse3,dic_ordr)
SQL> 		VALUES ('&MODNM.','REPORT_TYPES','CUST_SQL_MEM_REPORT'	  ,'SQL memory report (custom)' 	      ,152,null,null,20);
SQL> INSERT INTO
SQL>   opas_dictionary (modname,dic_name,val,display_val,sparse1,sparse2,sparse3,dic_ordr)
SQL> 		VALUES ('&MODNM.','REPORT_TYPES','AWR_REPORT'		  ,'AWR report (standard)'		      ,153,null,null,30);
SQL> INSERT INTO
SQL>   opas_dictionary (modname,dic_name,val,display_val,sparse1,sparse2,sparse3,dic_ordr)
SQL> 		VALUES ('&MODNM.','REPORT_TYPES','AWR_SQL_REPORT'	  ,'AWR SQL report (standard)'		      ,154,null,null,40);
SQL> INSERT INTO
SQL>   opas_dictionary (modname,dic_name,val,display_val,sparse1,sparse2,sparse3,dic_ordr)
SQL> 		VALUES ('&MODNM.','REPORT_TYPES','AWR_DIFF'		  ,'AWR diff (standard)'		      ,155,null,null,50);
SQL> INSERT INTO
SQL>   opas_dictionary (modname,dic_name,val,display_val,sparse1,sparse2,sparse3,dic_ordr)
SQL> 		VALUES ('&MODNM.','REPORT_TYPES','ASH_REPORT'		  ,'ASH report (standard)'		      ,156,null,null,60);
SQL> 
SQL> @@upgrade_data_1.3.7_1.3.8.sql
SQL> @@upgrade_data_1.3.9_1.3.10.sql
SQL> 
SQL> set define ~
SQL> 
SQL> declare
SQL>   l_script clob;
SQL> begin
SQL>   l_script :=
SQL> q'[
SQL> @../modules/core/scripts/opasawr.css
SQL> ]';
SQL>   delete from opas_scripts where script_id='PROC_AWRCSS';
SQL>   insert into opas_scripts (script_id,modname,script_content) values ('PROC_AWRCSS','~MODNM.',l_script);
SQL> 
SQL>   l_script :=
SQL> q'^
SQL> @../modules/core/scripts/__prn_tbl_html.sql
SQL> ^';
SQL>   delete from opas_scripts where script_id='PROC_PRNHTMLTBL';
SQL>   insert into opas_scripts (script_id,modname,script_content) values ('PROC_PRNHTMLTBL','~MODNM.',l_script);
SQL>   COREMOD_REPORT_UTILS.prepare_saved_sql_script (	P_SCRIPT_NAME => 'PROC_PRNHTMLTBL');
SQL> 
SQL>   l_script :=
SQL> q'^
SQL> @../modules/core/scripts/__getftxt.sql
SQL> ^';
SQL>   delete from opas_scripts where script_id='PROC_GETGTXT';
SQL>   insert into opas_scripts (script_id,modname,script_content) values ('PROC_GETGTXT','~MODNM.',l_script);
SQL>   COREMOD_REPORT_UTILS.prepare_saved_sql_script (	P_SCRIPT_NAME => 'PROC_GETGTXT');
SQL> 
SQL>   l_script :=
SQL> q'^
SQL> @../modules/core/scripts/__nonshared1.sql
SQL> ^';
SQL>   delete from opas_scripts where script_id='PROC_NON_SHARED';
SQL>   insert into opas_scripts (script_id,modname,script_content) values ('PROC_NON_SHARED','~MODNM.',l_script);
SQL>   COREMOD_REPORT_UTILS.prepare_saved_sql_script (	P_SCRIPT_NAME => 'PROC_NON_SHARED');
SQL> 
SQL>   l_script :=
SQL> q'^
SQL> @../modules/core/scripts/__vsql_stat.sql
SQL> ^';
SQL>   delete from opas_scripts where script_id='PROC_VSQL_STAT';
SQL>   insert into opas_scripts (script_id,modname,script_content) values ('PROC_VSQL_STAT','~MODNM.',l_script);
SQL>   COREMOD_REPORT_UTILS.prepare_saved_sql_script (	P_SCRIPT_NAME => 'PROC_VSQL_STAT');
SQL> 
SQL>   l_script :=
SQL> q'^
SQL> @../modules/core/scripts/__offload_percent1.sql
SQL> ^';
SQL>   delete from opas_scripts where script_id='PROC_OFFLOAD_PCT1';
SQL>   insert into opas_scripts (script_id,modname,script_content) values ('PROC_OFFLOAD_PCT1','~MODNM.',l_script);
SQL>   COREMOD_REPORT_UTILS.prepare_saved_sql_script (	P_SCRIPT_NAME => 'PROC_OFFLOAD_PCT1');
SQL> 
SQL>   l_script :=
SQL> q'^
SQL> @../modules/core/scripts/__offload_percent2.sql
SQL> ^';
SQL>   delete from opas_scripts where script_id='PROC_OFFLOAD_PCT2';
SQL>   insert into opas_scripts (script_id,modname,script_content) values ('PROC_OFFLOAD_PCT2','~MODNM.',l_script);
SQL>   COREMOD_REPORT_UTILS.prepare_saved_sql_script (	P_SCRIPT_NAME => 'PROC_OFFLOAD_PCT2');
SQL> 
SQL>   l_script :=
SQL> q'^
SQL> @../modules/core/scripts/__sqlmon1.sql
SQL> ^';
SQL>   delete from opas_scripts where script_id='PROC_SQLMON';
SQL>   insert into opas_scripts (script_id,modname,script_content) values ('PROC_SQLMON','~MODNM.',l_script);
SQL>   COREMOD_REPORT_UTILS.prepare_saved_sql_script (	P_SCRIPT_NAME => 'PROC_SQLMON');
SQL> 
SQL>   l_script :=
SQL> q'^
SQL> @../modules/core/scripts/__sqlwarea.sql
SQL> ^';
SQL>   delete from opas_scripts where script_id='PROC_SQLWORKAREA';
SQL>   insert into opas_scripts (script_id,modname,script_content) values ('PROC_SQLWORKAREA','~MODNM.',l_script);
SQL>   COREMOD_REPORT_UTILS.prepare_saved_sql_script (	P_SCRIPT_NAME => 'PROC_SQLWORKAREA');
SQL> 
SQL>   l_script :=
SQL> q'^
SQL> @../modules/core/scripts/__optenv.sql
SQL> ^';
SQL>   delete from opas_scripts where script_id='PROC_OPTENV';
SQL>   insert into opas_scripts (script_id,modname,script_content) values ('PROC_OPTENV','~MODNM.',l_script);
SQL>   COREMOD_REPORT_UTILS.prepare_saved_sql_script (	P_SCRIPT_NAME => 'PROC_OPTENV');
SQL> 
SQL>   l_script :=
SQL> q'^
SQL> @../modules/core/scripts/__rac_plans.sql
SQL> ^';
SQL>   delete from opas_scripts where script_id='PROC_RACPLAN';
SQL>   insert into opas_scripts (script_id,modname,script_content) values ('PROC_RACPLAN','~MODNM.',l_script);
SQL>   COREMOD_REPORT_UTILS.prepare_saved_sql_script (	P_SCRIPT_NAME => 'PROC_RACPLAN');
SQL> 
SQL>   l_script :=
SQL> q'^
SQL> @../modules/core/scripts/__sqlmon_hist.sql
SQL> ^';
SQL>   delete from opas_scripts where script_id='PROC_SQLMON_HIST';
SQL>   insert into opas_scripts (script_id,modname,script_content) values ('PROC_SQLMON_HIST','~MODNM.',l_script);
SQL>   COREMOD_REPORT_UTILS.prepare_saved_sql_script (	P_SCRIPT_NAME => 'PROC_SQLMON_HIST');
SQL> 
SQL>   l_script :=
SQL> q'[
SQL> @../modules/core/scripts/__ash_p3
SQL> ]';
SQL>   delete from opas_scripts where script_id='PROC_AWRASHP3';
SQL>   insert into opas_scripts (script_id,modname,script_content) values ('PROC_AWRASHP3','~MODNM.',l_script);
SQL>   COREMOD_REPORT_UTILS.prepare_saved_sql_script (	P_SCRIPT_NAME => 'PROC_AWRASHP3');
SQL> 
SQL>   l_script :=
SQL> q'[
SQL> @../modules/core/scripts/__ash_p3_1
SQL> ]';
SQL>   delete from opas_scripts where script_id='PROC_AWRASHP3_1';
SQL>   insert into opas_scripts (script_id,modname,script_content) values ('PROC_AWRASHP3_1','~MODNM.',l_script);
SQL>   COREMOD_REPORT_UTILS.prepare_saved_sql_script (	P_SCRIPT_NAME => 'PROC_AWRASHP3_1');
SQL> 
SQL> end;
SQL> /
SQL> 
SQL> declare
SQL>   l_script clob;
SQL> begin
SQL>   l_script :=
SQL> q'{
SQL> @../modules/core/scripts/__sqlstat.sql
SQL> }';
SQL>   delete from opas_scripts where script_id='PROC_AWRSQLSTAT';
SQL>   insert into opas_scripts (script_id,modname,script_content) values ('PROC_AWRSQLSTAT','~MODNM.',l_script);
SQL>   COREMOD_REPORT_UTILS.prepare_saved_sql_script (	P_SCRIPT_NAME => 'PROC_AWRSQLSTAT');
SQL> 
SQL>   l_script :=
SQL> q'[
SQL> @../modules/core/scripts/__ash_summ
SQL> ]';
SQL>   delete from opas_scripts where script_id='PROC_AWRASHSUMM';
SQL>   insert into opas_scripts (script_id,modname,script_content) values ('PROC_AWRASHSUMM','~MODNM.',l_script);
SQL>   COREMOD_REPORT_UTILS.prepare_saved_sql_script (	P_SCRIPT_NAME => 'PROC_AWRASHSUMM');
SQL> 
SQL>   l_script :=
SQL> q'[
SQL> @../modules/core/scripts/__ash_p1
SQL> ]';
SQL>   delete from opas_scripts where script_id='PROC_AWRASHP1';
SQL>   insert into opas_scripts (script_id,modname,script_content) values ('PROC_AWRASHP1','~MODNM.',l_script);
SQL>   COREMOD_REPORT_UTILS.prepare_saved_sql_script (	P_SCRIPT_NAME => 'PROC_AWRASHP1');
SQL> 
SQL>   l_script :=
SQL> q'[
SQL> @../modules/core/scripts/__ash_p1_1
SQL> ]';
SQL>   delete from opas_scripts where script_id='PROC_AWRASHP1_1';
SQL>   insert into opas_scripts (script_id,modname,script_content) values ('PROC_AWRASHP1_1','~MODNM.',l_script);
SQL>   COREMOD_REPORT_UTILS.prepare_saved_sql_script (	P_SCRIPT_NAME => 'PROC_AWRASHP1_1');
SQL> 
SQL>   l_script :=
SQL> q'[
SQL> @../modules/core/scripts/__ash_p2
SQL> ]';
SQL>   delete from opas_scripts where script_id='PROC_AWRASHP2';
SQL>   insert into opas_scripts (script_id,modname,script_content) values ('PROC_AWRASHP2','~MODNM.',l_script);
SQL>   COREMOD_REPORT_UTILS.prepare_saved_sql_script (	P_SCRIPT_NAME => 'PROC_AWRASHP2');
SQL> 
SQL> end;
SQL> /
SQL> 
SQL> 
SQL> 
SQL> set define &
SQL> 
SQL> INSERT INTO opas_groups2apexusr ( group_id, modname, apex_user) VALUES ( 0, 'OPASCORE', upper('&namepref.')||'ADM');
SQL> */
SQL> 
SQL> 
SQL> commit;

Commit complete.

SQL> 
SQL> exec coremod_tasks.create_task_job;

PL/SQL procedure successfully completed.

SQL> /*
SQL> exec coremod_cleanup.create_cleanup_job;
SQL> 
SQL> 
SQL> begin
SQL>   coremod_cleanup.register_cleanup_tasks (  P_TASKNAME => 'CLEANUPLOGS',
SQL> 						 P_MODNAME => '&MODNM.',
SQL> 						 p_task_body => 'begin COREMOD_LOG.cleanup_logs; end;');
SQL>   coremod_cleanup.register_cleanup_tasks (  P_TASKNAME => 'CLEANUPTASKSDATA',
SQL> 						 P_MODNAME => '&MODNM.',
SQL> 						 p_task_body => 'begin coremod_tasks.cleanup_tasks; end;');
SQL>   coremod_cleanup.register_cleanup_tasks (  P_TASKNAME => 'CLEANUPCACHE',
SQL> 						 P_MODNAME => '&MODNM.',
SQL> 						 p_task_body => 'begin COREMOD_REPORT_UTILS.CLEANUP_CACHE; end;');
SQL> 
SQL> end;
SQL> /
SQL> 
SQL> begin
SQL>   COREMOD_TASKS.create_task (  p_taskname	=> 'OPAS_REPORT',
SQL> 				    p_modname	=> '&MODNM.',
SQL> 				    p_is_public => 'Y',
SQL> 								p_task_priority => COREMOD_TASKS.tpNORM,
SQL> 				    p_task_body => 'begin coremod_report_utils.execute_report (p_report_id => <B1>) ; end;');
SQL> end;
SQL> /
SQL> 
SQL> 
SQL> begin
SQL>   COREMOD_TASKS.create_task (  p_taskname	=> 'OPAS_UPLOAD_IMP_FILE',
SQL> 				    p_modname	=> '&MODNM.',
SQL> 				    p_is_public => 'Y',
SQL> 				    p_task_body => 'begin COREMOD_EXPIMP.import_file (p_exp_sess_id => <B1>) ; end;');
SQL> end;
SQL> /
SQL> 
SQL> commit;
SQL> 
SQL> begin
SQL>   COREMOD_EXPIMP.init();
SQL> end;
SQL> /
SQL> 
SQL> */
SQL> 
SQL> --SQL Trace
SQL> --@../modules/sql_trace/install/install.sql
SQL> 
SQL> --ASH Analyzer
SQL> --@../modules/ash_analyzer/install/install.sql
SQL> 
SQL> --AWR WareHouse
SQL> --@../modules/awr_warehouse/install/install.sql
SQL> 
SQL> --DB Growth Tracker
SQL> --@../modules/db_growth/install/install.sql
SQL> 
SQL> 
SQL> conn &localscheme./&localscheme.@&localdb.
Connected.
SQL> 
SQL> set pages 999
SQL> set lines 200
SQL> 
SQL> select * from user_errors order by 1,2,3,4,5;

NAME                                                                                                                             TYPE                  SEQUENCE       LINE   POSITION                   
-------------------------------------------------------------------------------------------------------------------------------- ------------------- ---------- ---------- ----------                   
TEXT                                                                                                                                                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ATTRIBUTE MESSAGE_NUMBER                                                                                                                                                                                
--------- --------------                                                                                                                                                                                
V$OPAS_EXPIMP_SESSIONS                                                                                                           VIEW                         1          0          0                   
ORA-00904: "COREMOD_API"."GETCONF": invalid identifier                                                                                                                                                  
ERROR                  0                                                                                                                                                                                
                                                                                                                                                                                                        
V$OPAS_FILE_CONTENTBYROW                                                                                                         VIEW                         1          0          0                   
ORA-00904: "COREMOD_UTILS"."CLOB2TAB": invalid identifier                                                                                                                                               
ERROR                  0                                                                                                                                                                                
                                                                                                                                                                                                        
V$OPAS_TASK_QUEUE                                                                                                                VIEW                         1          0          0                   
ORA-00904: "COREMOD_SEC"."IS_ROLE_ASSIGNED_N": invalid identifier                                                                                                                                       
ERROR                  0                                                                                                                                                                                
                                                                                                                                                                                                        
V$OPAS_TASK_QUEUE_LONGOPS                                                                                                        VIEW                         1          0          0                   
ORA-04063: view "OPAS60DEV.V$OPAS_TASK_QUEUE" has errors                                                                                                                                                
ERROR                  0                                                                                                                                                                                
                                                                                                                                                                                                        

SQL> 
SQL> begin
  2    dbms_utility.compile_schema(user);
  3  end;
  4  /

PL/SQL procedure successfully completed.

SQL> 
SQL> select * from user_errors order by 1,2,3,4,5;

no rows selected

SQL> 
SQL> set pages 999
SQL> set lines 200
SQL> column MODNAME format a32 word_wrapped
SQL> column MODDESCR format a100 word_wrapped
SQL> select t.modname, t.modver, to_char(t.installed,'YYYY/MON/DD HH24:MI:SS') installed, t.moddescr from opas_modules t order by t.installed;

MODNAME                          MODVER                           INSTALLED                     MODDESCR                                                                                                
-------------------------------- -------------------------------- ----------------------------- ----------------------------------------------------------------------------------------------------    
OPASCORE                         2.0.0                            2019/OCT/08 16:35:23          Core Module                                                                                             
OPASAPP                          6.0.0                            2019/OCT/08 16:35:23          Oracle Performance Analytic Suite Application                                                           

SQL> disc
Disconnected from Oracle Database 18c Enterprise Edition Release 18.0.0.0.0 - Production
SQL> 
SQL> spool off
